/******************************************************************************
**
** <auto-generated>
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.6.9, using .NET Server 3.3.0 template (version 0)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
** </auto-generated>
**
** Copyright (c) 2006-2023 Unified Automation GmbH All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** Project: .NET OPC UA SDK information model for namespace http://opcfoundation.org/UA/IA/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
******************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using OpcUa.DI;
using UnifiedAutomation.UaBase;
using UnifiedAutomation.UaServer;

namespace OpcUa.IA
{
    #region AcousticSignalModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/5.2.9
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.AcousticSignalType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class AcousticSignalModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="AcousticSignalModel" /> class.
        /// </summary>
        public AcousticSignalModel() : this((AcousticSignalModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AcousticSignalModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public AcousticSignalModel(AcousticSignalModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.AudioSample != null)
                {
                    AudioSample = template.AudioSample.Clone() as byte[];
                }
                NumberInList = template.NumberInList;
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the AudioSample
        /// </summary>
        /// <details>
        /// Contains the audio data, e.g. for devices capable of audio playback.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public byte[] AudioSample
        {
            get => m_AudioSample;
            set => SetField(ref m_AudioSample, value, nameof(AudioSample));
        }
        private byte[] m_AudioSample;

        /// <summary>
        /// Gets or sets the NumberInList
        /// </summary>
        /// <details>
        /// Enumerate the acoustic signals. Instances of StackElementAcousticType index into this number using the OperationMode Property.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.OpcUa)]
        public object NumberInList
        {
            get => m_NumberInList;
            set => SetField(ref m_NumberInList, value, nameof(NumberInList));
        }
        private object m_NumberInList;


        #endregion
    }
    #endregion


    #region BaseCalibrationTargetCategoryModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/7.4.2
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.BaseCalibrationTargetCategoryType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class BaseCalibrationTargetCategoryModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="BaseCalibrationTargetCategoryModel" /> class.
        /// </summary>
        public BaseCalibrationTargetCategoryModel() : this((BaseCalibrationTargetCategoryModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BaseCalibrationTargetCategoryModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public BaseCalibrationTargetCategoryModel(BaseCalibrationTargetCategoryModel template, DummyArgument dummy = null) : base(template)
        {
        }
        #endregion

        #region Public Properties

        #endregion
    }
    #endregion


    #region DynamicCalibrationTargetCategoryModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/7.4.6
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.DynamicCalibrationTargetCategoryType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class DynamicCalibrationTargetCategoryModel : BaseCalibrationTargetCategoryModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="DynamicCalibrationTargetCategoryModel" /> class.
        /// </summary>
        public DynamicCalibrationTargetCategoryModel() : this((DynamicCalibrationTargetCategoryModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DynamicCalibrationTargetCategoryModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public DynamicCalibrationTargetCategoryModel(DynamicCalibrationTargetCategoryModel template, DummyArgument dummy = null) : base(template)
        {
        }
        #endregion

        #region Public Properties

        #endregion
    }
    #endregion


    #region OneTimeCalibrationTargetCategoryModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/7.4.5
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.OneTimeCalibrationTargetCategoryType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class OneTimeCalibrationTargetCategoryModel : BaseCalibrationTargetCategoryModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="OneTimeCalibrationTargetCategoryModel" /> class.
        /// </summary>
        public OneTimeCalibrationTargetCategoryModel() : this((OneTimeCalibrationTargetCategoryModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="OneTimeCalibrationTargetCategoryModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public OneTimeCalibrationTargetCategoryModel(OneTimeCalibrationTargetCategoryModel template, DummyArgument dummy = null) : base(template)
        {
        }
        #endregion

        #region Public Properties

        #endregion
    }
    #endregion


    #region ReusableCalibrationTargetCategoryModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/7.4.3
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.ReusableCalibrationTargetCategoryType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class ReusableCalibrationTargetCategoryModel : BaseCalibrationTargetCategoryModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="ReusableCalibrationTargetCategoryModel" /> class.
        /// </summary>
        public ReusableCalibrationTargetCategoryModel() : this((ReusableCalibrationTargetCategoryModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReusableCalibrationTargetCategoryModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public ReusableCalibrationTargetCategoryModel(ReusableCalibrationTargetCategoryModel template, DummyArgument dummy = null) : base(template)
        {
        }
        #endregion

        #region Public Properties

        #endregion
    }
    #endregion


    #region ReusableDeviceCalibrationTargetCategoryModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/7.4.4
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.ReusableDeviceCalibrationTargetCategoryType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class ReusableDeviceCalibrationTargetCategoryModel : ReusableCalibrationTargetCategoryModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="ReusableDeviceCalibrationTargetCategoryModel" /> class.
        /// </summary>
        public ReusableDeviceCalibrationTargetCategoryModel() : this((ReusableDeviceCalibrationTargetCategoryModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ReusableDeviceCalibrationTargetCategoryModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public ReusableDeviceCalibrationTargetCategoryModel(ReusableDeviceCalibrationTargetCategoryModel template, DummyArgument dummy = null) : base(template)
        {
        }
        #endregion

        #region Public Properties

        #endregion
    }
    #endregion


    #region IStatisticsModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/6.2.1/#6.2.1.1
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.IStatisticsType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class IStatisticsModel : BaseInterfaceModel, IMethodDispatcher
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="IStatisticsModel" /> class.
        /// </summary>
        public IStatisticsModel() : this((IStatisticsModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IStatisticsModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public IStatisticsModel(IStatisticsModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.StartTime != null)
                {
                    StartTime = template.StartTime;
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the StartTime
        /// </summary>
        /// <details>
        /// Indicates the point in time at which the collection of the statistical data has been started.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public DateTime? StartTime
        {
            get => m_StartTime;
            set => SetField(ref m_StartTime, value, nameof(StartTime));
        }
        private DateTime? m_StartTime;


        #endregion
        #region IMethodDispatcher Members
        /// <summary>
        /// Gets the method dispatcher.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="objectId">The object id.</param>
        /// <param name="methodId">The method id.</param>
        /// <returns></returns>
        public virtual CallMethodEventHandler GetMethodDispatcher(
            RequestContext context,
            NodeId objectId,
            NodeId methodId)
        {
            return DispatchMethod;
        }
        #endregion

        #region Public Methods

        /// <summary>
        /// Dispatches the method.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="methodHandle">The method handle.</param>
        /// <param name="inputArguments">The input arguments.</param>
        /// <param name="inputArgumentResults">The input argument results.</param>
        /// <param name="outputArguments">The output arguments.</param>
        /// <returns></returns>
        public virtual StatusCode DispatchMethod(
            RequestContext context,
            MethodHandle methodHandle,
            IList<Variant> inputArguments,
            List<StatusCode> inputArgumentResults,
            List<Variant> outputArguments)
        {
            IIStatisticsMethods implemention = IStatisticsMethods;

            if (implemention == null)
            {
                implemention = this as IIStatisticsMethods;
            }

            if (implemention == null)
            {
                return StatusCodes.BadUserAccessDenied;
            }

            ExpandedNodeId methodDeclarationId = NodeId.ToAbsoluteNodeId(methodHandle.MethodDeclarationId, context.NamespaceUris);

            if (methodDeclarationId == OpcUa.IA.MethodIds.IStatisticsType_ResetStatistics)
            {
                StatusCode ret = implemention.ResetStatistics(context, this);
                if (ret.IsGood())
                {
                }
                return ret;

            }
            return StatusCodes.BadMethodInvalid;
        }

        /// <summary>
        /// Gets or sets the IStatistics methods.
        /// </summary>
        /// <value>
        /// The IStatistics methods.
        /// </value>
        public IIStatisticsMethods IStatisticsMethods { get; set; }
        #endregion
    }

    /// <summary>
    /// The interface for methods implemented on the IStatisticsModel object.
    /// </summary>
    public interface IIStatisticsMethods
    {
        /// <summary>
        /// https://reference.opcfoundation.org/v105/IA/v102/docs/6.2.1/#6.2.1.2
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <returns></returns>
        StatusCode ResetStatistics(
            RequestContext context,
            IStatisticsModel model
            );


    }
    #endregion


    #region IAggregateStatisticsModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/6.2.2
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.IAggregateStatisticsType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class IAggregateStatisticsModel : IStatisticsModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="IAggregateStatisticsModel" /> class.
        /// </summary>
        public IAggregateStatisticsModel() : this((IAggregateStatisticsModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IAggregateStatisticsModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public IAggregateStatisticsModel(IAggregateStatisticsModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.ResetCondition != null)
                {
                    ResetCondition = template.ResetCondition.Clone() as string;
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the ResetCondition
        /// </summary>
        /// <details>
        /// The reason and context for the reset of the statistics, which is done without a trigger from an OPC UA Client, like calling the ResetStatistics Method. ResetCondition is a vendor-specific, human readable string. ResetCondition is non-localized and might contain an expression that can be parsed by certain clients. Examples are: \342\200\234AFTER 4 HOURS\342\200\235, \342\200\234AFTER 1000 ITEMS\342\200\235, \342\200\234OPERATOR\342\200\235. \342\200\234OPERATOR\342\200\235 means, that an operator resets the statistics on a local HMI.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public string ResetCondition
        {
            get => m_ResetCondition;
            set => SetField(ref m_ResetCondition, value, nameof(ResetCondition));
        }
        private string m_ResetCondition;


        #endregion
    }
    #endregion


    #region IRollingStatisticsModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/6.2.3
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.IRollingStatisticsType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class IRollingStatisticsModel : IStatisticsModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="IRollingStatisticsModel" /> class.
        /// </summary>
        public IRollingStatisticsModel() : this((IRollingStatisticsModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IRollingStatisticsModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public IRollingStatisticsModel(IRollingStatisticsModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.WindowDuration != null)
                {
                    WindowDuration = template.WindowDuration;
                }
                if (template.WindowNumberOfValues != null)
                {
                    WindowNumberOfValues = template.WindowNumberOfValues;
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the WindowDuration
        /// </summary>
        /// <details>
        /// The duration after the statistical data are rolled over. Only the data that were gathered during that duration are considered for the statistical data, even if the time intervals between the StartTime and the current time is longer.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public double? WindowDuration
        {
            get => m_WindowDuration;
            set => SetField(ref m_WindowDuration, value, nameof(WindowDuration));
        }
        private double? m_WindowDuration;

        /// <summary>
        /// Gets or sets the WindowNumberOfValues
        /// </summary>
        /// <details>
        /// The number of values before the data gets rolled over. For the statistical data, only the data fitting into the number of values is considered, even if more data were gathered since StartTime.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public uint? WindowNumberOfValues
        {
            get => m_WindowNumberOfValues;
            set => SetField(ref m_WindowNumberOfValues, value, nameof(WindowNumberOfValues));
        }
        private uint? m_WindowNumberOfValues;


        #endregion
    }
    #endregion


    #region CalibrationTargetModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/7.4.1
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.CalibrationTargetType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class CalibrationTargetModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="CalibrationTargetModel" /> class.
        /// </summary>
        public CalibrationTargetModel() : this((CalibrationTargetModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CalibrationTargetModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public CalibrationTargetModel(CalibrationTargetModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
                CalibrationTargetCategory = new BaseCalibrationTargetCategoryModel();
                CalibrationTargetFeatures = new FolderModel();
                Identification = new Identification_FunctionalGroupModel();
            }
            else
            {
                CalibrationTargetCategory = new BaseCalibrationTargetCategoryModel(template.CalibrationTargetCategory);
                CalibrationTargetFeatures = new FolderModel(template.CalibrationTargetFeatures);
                if (template.CertificateUri != null)
                {
                    CertificateUri = template.CertificateUri.Clone() as string;
                }
                Identification = new Identification_FunctionalGroupModel(template.Identification);
                if (template.LastValidationDate != null)
                {
                    LastValidationDate = template.LastValidationDate;
                }
                if (template.NextValidationDate != null)
                {
                    NextValidationDate = template.NextValidationDate;
                }
                if (template.OperationalConditions != null)
                {
                    OperationalConditions = new FolderModel(template.OperationalConditions);
                }
                if (template.Quality != null)
                {
                    Quality = template.Quality;
                }
            }
        }
        #endregion

        #region Nested Classes
        /// <summary>
        /// Helper class for CalibrationTargetModel.Identification
        /// </summary>
        public partial class Identification_FunctionalGroupModel : FunctionalGroupModel
        {
            /// <remarks/>
            public Identification_FunctionalGroupModel(Identification_FunctionalGroupModel template = null, DummyArgument dummy = null): base(template)
            {
                if (template == null)
                {
                }
                else
                {
                    if (template.AssetId != null)
                    {
                        AssetId = template.AssetId.Clone() as string;
                    }
                    if (template.ComponentName != null)
                    {
                        ComponentName = template.ComponentName.Clone() as LocalizedText;
                    }
                    if (template.DeviceClass != null)
                    {
                        DeviceClass = template.DeviceClass.Clone() as string;
                    }
                    if (template.DeviceManual != null)
                    {
                        DeviceManual = template.DeviceManual.Clone() as string;
                    }
                    if (template.DeviceRevision != null)
                    {
                        DeviceRevision = template.DeviceRevision.Clone() as string;
                    }
                    if (template.HardwareRevision != null)
                    {
                        HardwareRevision = template.HardwareRevision.Clone() as string;
                    }
                    if (template.Manufacturer != null)
                    {
                        Manufacturer = template.Manufacturer.Clone() as LocalizedText;
                    }
                    if (template.ManufacturerUri != null)
                    {
                        ManufacturerUri = template.ManufacturerUri.Clone() as string;
                    }
                    if (template.Model != null)
                    {
                        Model = template.Model.Clone() as LocalizedText;
                    }
                    if (template.ProductCode != null)
                    {
                        ProductCode = template.ProductCode.Clone() as string;
                    }
                    if (template.ProductInstanceUri != null)
                    {
                        ProductInstanceUri = template.ProductInstanceUri.Clone() as string;
                    }
                    if (template.RevisionCounter != null)
                    {
                        RevisionCounter = template.RevisionCounter;
                    }
                    if (template.SerialNumber != null)
                    {
                        SerialNumber = template.SerialNumber.Clone() as string;
                    }
                    if (template.SoftwareRevision != null)
                    {
                        SoftwareRevision = template.SoftwareRevision.Clone() as string;
                    }
                }
            }
            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public string AssetId
            {
                get => m_AssetId;
                set => SetField(ref m_AssetId, value, nameof(AssetId));
            }
            private string m_AssetId;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public LocalizedText ComponentName
            {
                get => m_ComponentName;
                set => SetField(ref m_ComponentName, value, nameof(ComponentName));
            }
            private LocalizedText m_ComponentName;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public string DeviceClass
            {
                get => m_DeviceClass;
                set => SetField(ref m_DeviceClass, value, nameof(DeviceClass));
            }
            private string m_DeviceClass;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public string DeviceManual
            {
                get => m_DeviceManual;
                set => SetField(ref m_DeviceManual, value, nameof(DeviceManual));
            }
            private string m_DeviceManual;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public string DeviceRevision
            {
                get => m_DeviceRevision;
                set => SetField(ref m_DeviceRevision, value, nameof(DeviceRevision));
            }
            private string m_DeviceRevision;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public string HardwareRevision
            {
                get => m_HardwareRevision;
                set => SetField(ref m_HardwareRevision, value, nameof(HardwareRevision));
            }
            private string m_HardwareRevision;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public LocalizedText Manufacturer
            {
                get => m_Manufacturer;
                set => SetField(ref m_Manufacturer, value, nameof(Manufacturer));
            }
            private LocalizedText m_Manufacturer;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public string ManufacturerUri
            {
                get => m_ManufacturerUri;
                set => SetField(ref m_ManufacturerUri, value, nameof(ManufacturerUri));
            }
            private string m_ManufacturerUri;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public LocalizedText Model
            {
                get => m_Model;
                set => SetField(ref m_Model, value, nameof(Model));
            }
            private LocalizedText m_Model;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public string ProductCode
            {
                get => m_ProductCode;
                set => SetField(ref m_ProductCode, value, nameof(ProductCode));
            }
            private string m_ProductCode;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public string ProductInstanceUri
            {
                get => m_ProductInstanceUri;
                set => SetField(ref m_ProductInstanceUri, value, nameof(ProductInstanceUri));
            }
            private string m_ProductInstanceUri;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public int? RevisionCounter
            {
                get => m_RevisionCounter;
                set => SetField(ref m_RevisionCounter, value, nameof(RevisionCounter));
            }
            private int? m_RevisionCounter;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public string SerialNumber
            {
                get => m_SerialNumber;
                set => SetField(ref m_SerialNumber, value, nameof(SerialNumber));
            }
            private string m_SerialNumber;

            /// <remarks/>
            [UaInstanceDeclaration(NamespaceUri=OpcUa.IA.Namespaces.DI)]
            public string SoftwareRevision
            {
                get => m_SoftwareRevision;
                set => SetField(ref m_SoftwareRevision, value, nameof(SoftwareRevision));
            }
            private string m_SoftwareRevision;

        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the CalibrationTargetCategory
        /// </summary>
        /// <details>
        /// Defines what category the calibration target is of.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public BaseCalibrationTargetCategoryModel CalibrationTargetCategory { get; set; }

        /// <summary>
        /// Gets or sets the CalibrationTargetFeatures
        /// </summary>
        /// <details>
        /// A folder containing information about the features of a calibration target, that is, what can be calibrated with the calibration target.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public FolderModel CalibrationTargetFeatures { get; set; }

        /// <summary>
        /// Gets or sets the CertificateUri
        /// </summary>
        /// <details>
        /// Contains the Uri of a certificate of the calibration target, in case the calibration target is certified and the information available. Otherwise, the Property should be omitted.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public string CertificateUri
        {
            get => m_CertificateUri;
            set => SetField(ref m_CertificateUri, value, nameof(CertificateUri));
        }
        private string m_CertificateUri;

        /// <summary>
        /// Gets or sets the Identification
        /// </summary>
        /// <details>
        /// Provides identification information.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public Identification_FunctionalGroupModel Identification { get; set; }

        /// <summary>
        /// Gets or sets the LastValidationDate
        /// </summary>
        /// <details>
        /// Provides the date, the calibration target was validated the last time. If there is no specific validation date known, the date when the calibration target was bought or created should be used.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public DateTime? LastValidationDate
        {
            get => m_LastValidationDate;
            set => SetField(ref m_LastValidationDate, value, nameof(LastValidationDate));
        }
        private DateTime? m_LastValidationDate;

        /// <summary>
        /// Gets or sets the NextValidationDate
        /// </summary>
        /// <details>
        /// Provides the date, when the calibration target should be validated the next time. If this date is not known, the Property should be omitted. Note: Potentially the NextValidationDate is in the past, when the next validation did not take place.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public DateTime? NextValidationDate
        {
            get => m_NextValidationDate;
            set => SetField(ref m_NextValidationDate, value, nameof(NextValidationDate));
        }
        private DateTime? m_NextValidationDate;

        /// <summary>
        /// Gets or sets the OperationalConditions
        /// </summary>
        /// <details>
        /// A folder containing information about operational conditions of the calibration target. For example, it might provide in what ranges of humidity the calibration target can be operated. It might also provide correction information, for example, depending on the temperature the calibration values need to be corrected (in case of a length, the length might increase with high temperatures). If no operational conditions are provided, this folder should be omitted.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public FolderModel OperationalConditions { get; set; }

        /// <summary>
        /// Gets or sets the Quality
        /// </summary>
        /// <details>
        /// Provides the quality of the calibration target in percentage, this is, the value shall be between 0 and 100. 100 means the highest quality, 0 the lowest. The semantic of the quality is application-specific.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public byte? Quality
        {
            get => m_Quality;
            set => SetField(ref m_Quality, value, nameof(Quality));
        }
        private byte? m_Quality;


        #endregion
    }
    #endregion


    #region ControlChannelModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/5.2.8
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.ControlChannelType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class ControlChannelModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="ControlChannelModel" /> class.
        /// </summary>
        public ControlChannelModel() : this((ControlChannelModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ControlChannelModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public ControlChannelModel(ControlChannelModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                ChannelColor = template.ChannelColor;
                if (template.Intensity != null)
                {
                    Intensity = new AnalogItemModel<float>(template.Intensity);
                }
                SignalMode = template.SignalMode;
                SignalOn = template.SignalOn;
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the ChannelColor
        /// </summary>
        /// <details>
        /// Indicates in what mode (continuously on, blinking, flashing) the channel operates when switched on.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public SignalColor ChannelColor
        {
            get => m_ChannelColor;
            set => SetField(ref m_ChannelColor, value, nameof(ChannelColor));
        }
        private SignalColor m_ChannelColor;

        /// <summary>
        /// Gets or sets the Intensity
        /// </summary>
        /// <details>
        /// Shows the channel\342\200\231s intensity, thus its brightness. The mandatory EURange Property of the Variable indicates the lowest and highest value and thereby allows to calculate the percentage represented by the value. The lowest value is interpreted as 0 percent, the highest is interpreted as 100 percent.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public AnalogItemModel<float> Intensity { get; set; }

        /// <summary>
        /// Gets or sets the SignalMode
        /// </summary>
        /// <details>
        /// Contains a list of audio signals used by this acoustic stacklight element.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public SignalModeLight SignalMode
        {
            get => m_SignalMode;
            set => SetField(ref m_SignalMode, value, nameof(SignalMode));
        }
        private SignalModeLight m_SignalMode;

        /// <summary>
        /// Gets or sets the SignalOn
        /// </summary>
        /// <details>
        /// Indicates if the colour is switched on.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public bool SignalOn
        {
            get => m_SignalOn;
            set => SetField(ref m_SignalOn, value, nameof(SignalOn));
        }
        private bool m_SignalOn;


        #endregion
    }
    #endregion


    #region BasicStacklightModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/5.2.1
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.BasicStacklightType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class BasicStacklightModel : OrderedListModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="BasicStacklightModel" /> class.
        /// </summary>
        public BasicStacklightModel() : this((BasicStacklightModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BasicStacklightModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public BasicStacklightModel(BasicStacklightModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.StackLevel != null)
                {
                    StackLevel = new StackLevelModel(template.StackLevel);
                }
                StacklightMode = template.StacklightMode;
                if (template.StackRunning != null)
                {
                    StackRunning = new StackRunningModel(template.StackRunning);
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the StackLevel
        /// </summary>
        /// <details>
        /// Valid if the stacklight is used in \342\200\234Levelmeter\342\200\235 StacklightMode. If so, the whole stack is controlled by a single percentual value. In this case, the SignalOn parameter of any stack element of StackElementLightType has no meaning.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public StackLevelModel StackLevel { get; set; }

        /// <summary>
        /// Gets or sets the StacklightMode
        /// </summary>
        /// <details>
        /// Shows in what way (stack of individual lights, level meter, running light) the stacklight unit is used.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public StacklightOperationMode StacklightMode
        {
            get => m_StacklightMode;
            set => SetField(ref m_StacklightMode, value, nameof(StacklightMode));
        }
        private StacklightOperationMode m_StacklightMode;

        /// <summary>
        /// Gets or sets the StackRunning
        /// </summary>
        /// <details>
        /// Valid if the stacklight is used in \342\200\234Running_Light\342\200\235 StacklightMode.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public StackRunningModel StackRunning { get; set; }


        #endregion
    }
    #endregion


    #region StacklightModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/5.2.2
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.StacklightType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class StacklightModel : BasicStacklightModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="StacklightModel" /> class.
        /// </summary>
        public StacklightModel() : this((StacklightModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StacklightModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public StacklightModel(StacklightModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.DeviceHealth != null)
                {
                    DeviceHealth = template.DeviceHealth;
                }
                if (template.DeviceHealthAlarms != null)
                {
                    DeviceHealthAlarms = new FolderModel(template.DeviceHealthAlarms);
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the DeviceHealth
        /// </summary>
        /// <details>
        /// Contains the health status information of the stacklight.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public DeviceHealthEnumeration? DeviceHealth
        {
            get => m_DeviceHealth;
            set => SetField(ref m_DeviceHealth, value, nameof(DeviceHealth));
        }
        private DeviceHealthEnumeration? m_DeviceHealth;

        /// <summary>
        /// Gets or sets the DeviceHealthAlarms
        /// </summary>
        /// <details>
        /// Contains alarms of the stacklights providing more detailed information on the health of the stacklight.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public FolderModel DeviceHealthAlarms { get; set; }


        #endregion
    }
    #endregion


    #region StackElementModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/5.2.5
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.StackElementType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class StackElementModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="StackElementModel" /> class.
        /// </summary>
        public StackElementModel() : this((StackElementModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StackElementModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public StackElementModel(StackElementModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.IsPartOfBase != null)
                {
                    IsPartOfBase = template.IsPartOfBase;
                }
                NumberInList = template.NumberInList;
                if (template.SignalOn != null)
                {
                    SignalOn = template.SignalOn;
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the IsPartOfBase
        /// </summary>
        /// <details>
        /// Indicates, if the element is contained in the mounting base of the stacklight. All elements contained in the mounting base shall be at the beginning of the list of stack elements.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public bool? IsPartOfBase
        {
            get => m_IsPartOfBase;
            set => SetField(ref m_IsPartOfBase, value, nameof(IsPartOfBase));
        }
        private bool? m_IsPartOfBase;

        /// <summary>
        /// Gets or sets the NumberInList
        /// </summary>
        /// <details>
        /// Enumerate the stacklight elements counting upwards beginning from the base of the stacklight.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.OpcUa)]
        public object NumberInList
        {
            get => m_NumberInList;
            set => SetField(ref m_NumberInList, value, nameof(NumberInList));
        }
        private object m_NumberInList;

        /// <summary>
        /// Gets or sets the SignalOn
        /// </summary>
        /// <details>
        /// Indicates if the signal emitted by the stack element is currently switched on or not.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public bool? SignalOn
        {
            get => m_SignalOn;
            set => SetField(ref m_SignalOn, value, nameof(SignalOn));
        }
        private bool? m_SignalOn;


        #endregion
    }
    #endregion


    #region StackElementAcousticModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/5.2.7
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.StackElementAcousticType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class StackElementAcousticModel : StackElementModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="StackElementAcousticModel" /> class.
        /// </summary>
        public StackElementAcousticModel() : this((StackElementAcousticModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StackElementAcousticModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public StackElementAcousticModel(StackElementAcousticModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
                AcousticSignals = new OrderedListModel();
            }
            else
            {
                AcousticSignals = new OrderedListModel(template.AcousticSignals);
                if (template.Intensity != null)
                {
                    Intensity = new AnalogItemModel<float>(template.Intensity);
                }
                OperationMode = template.OperationMode;
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the AcousticSignals
        /// </summary>
        /// <details>
        /// Contains a list of audio signals used by this acoustic stacklight element.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public OrderedListModel AcousticSignals { get; set; }

        /// <summary>
        /// Gets or sets the Intensity
        /// </summary>
        /// <details>
        /// Indicates the sound pressure level of the acoustic signal when switched on. This value shall only have positive values. The mandatory EURange Property of the Variable indicates the lowest and highest value and thereby allows to calculate the percentage represented by the value. The lowest value is interpreted as 0 percent, the highest is interpreted as 100 percent.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public AnalogItemModel<float> Intensity { get; set; }

        /// <summary>
        /// Gets or sets the OperationMode
        /// </summary>
        /// <details>
        /// Indicates what signal of the list of AcousticSignalType nodes is played when the acoustic element is switched on. It shall contain an index into the NumberInList of the respective AcousticSignalType Object of AcousticSignals.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public object OperationMode
        {
            get => m_OperationMode;
            set => SetField(ref m_OperationMode, value, nameof(OperationMode));
        }
        private object m_OperationMode;


        #endregion
    }
    #endregion


    #region StackElementLightModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/5.2.6
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.StackElementLightType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class StackElementLightModel : StackElementModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="StackElementLightModel" /> class.
        /// </summary>
        public StackElementLightModel() : this((StackElementLightModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StackElementLightModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public StackElementLightModel(StackElementLightModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.Intensity != null)
                {
                    Intensity = new AnalogItemModel<float>(template.Intensity);
                }
                if (template.SignalColor != null)
                {
                    SignalColor = template.SignalColor;
                }
                if (template.SignalMode != null)
                {
                    SignalMode = template.SignalMode;
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the Intensity
        /// </summary>
        /// <details>
        /// Intensity of the lamp, thus its brightness. The mandatory EURange Property of the Variable indicates the lowest and highest value and thereby allows to calculate the percentage represented by the value. The lowest value is interpreted as 0 percent, the highest is interpreted as 100 percent.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public AnalogItemModel<float> Intensity { get; set; }

        /// <summary>
        /// Gets or sets the SignalColor
        /// </summary>
        /// <details>
        /// Indicates the colour the lamp element has when switched on.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public SignalColor? SignalColor
        {
            get => m_SignalColor;
            set => SetField(ref m_SignalColor, value, nameof(SignalColor));
        }
        private SignalColor? m_SignalColor;

        /// <summary>
        /// Gets or sets the SignalMode
        /// </summary>
        /// <details>
        /// Shows in what way the lamp is used (continuous light, flashing, blinking) when switched on.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public SignalModeLight? SignalMode
        {
            get => m_SignalMode;
            set => SetField(ref m_SignalMode, value, nameof(SignalMode));
        }
        private SignalModeLight? m_SignalMode;


        #endregion
    }
    #endregion


    #region StackLevelModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/5.2.3
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.StackLevelType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class StackLevelModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="StackLevelModel" /> class.
        /// </summary>
        public StackLevelModel() : this((StackLevelModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StackLevelModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public StackLevelModel(StackLevelModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
                LevelPercent = new AnalogItemModel<float>();
            }
            else
            {
                DisplayMode = template.DisplayMode;
                LevelPercent = new AnalogItemModel<float>(template.LevelPercent);
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the DisplayMode
        /// </summary>
        /// <details>
        /// Indicates in what way the percentual value is displayed with the stacklight.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public LevelDisplayMode DisplayMode
        {
            get => m_DisplayMode;
            set => SetField(ref m_DisplayMode, value, nameof(DisplayMode));
        }
        private LevelDisplayMode m_DisplayMode;

        /// <summary>
        /// Gets or sets the LevelPercent
        /// </summary>
        /// <details>
        /// Shows the percentual value the stacklight is representing. The mandatory EURange Property of the Variable indicates the lowest and highest value and thereby allows to calculate the percentage represented by the value. The lowest value is interpreted as 0 percent, the highest is interpreted as 100 percent.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public AnalogItemModel<float> LevelPercent { get; set; }


        #endregion
    }
    #endregion


    #region StackRunningModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/5.2.4
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.StackRunningType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class StackRunningModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="StackRunningModel" /> class.
        /// </summary>
        public StackRunningModel() : this((StackRunningModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StackRunningModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public StackRunningModel(StackRunningModel template, DummyArgument dummy = null) : base(template)
        {
        }
        #endregion

        #region Public Properties

        #endregion
    }
    #endregion


    #region CalibrationValueModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/7.5.1
    /// </summary>
    [UaTypeDefinition(NodeId=VariableTypes.CalibrationValueType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class CalibrationValueModel : DataItemModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="CalibrationValueModel" /> class.
        /// </summary>
        public CalibrationValueModel() : this((CalibrationValueModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CalibrationValueModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public CalibrationValueModel(CalibrationValueModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                EngineeringUnits = template.EngineeringUnits == null ? null : template.EngineeringUnits.Clone() as EUInformation;
            }
        }
        #endregion

        #region Public Properties


        /// <summary>
        /// Gets or sets the EngineeringUnits
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.OpcUa)]
        public EUInformation EngineeringUnits
        {
            get => m_EngineeringUnits;
            set => SetField(ref m_EngineeringUnits, value, nameof(EngineeringUnits));
        }
        private EUInformation m_EngineeringUnits;


        #endregion
    }
    /// <summary>
    /// A typed object which represents a CalibrationValueType.
    /// </summary>
    public partial class CalibrationValueModel<T> : CalibrationValueModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="CalibrationValueModel" /> class.
        /// </summary>
        public CalibrationValueModel() : this((CalibrationValueModel<T>)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CalibrationValueModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        public CalibrationValueModel(CalibrationValueModel<T> template) : base(template)
        {
            if (template != null)
            {
                Value = (T) template.Value;
            }
        }
        #endregion

        /// <summary>
        /// Gets or sets the value.
        /// </summary>
        /// <value>
        /// The value.
        /// </value>
        [UaInstanceDeclaration(IsValue = true, NamespaceUri = OpcUa.IA.Namespaces.IA)]
        public new T Value
        {
            get { return (T)((base.Value)??default(T)); }
            set { base.Value = value; }
        }
    }
    #endregion


    #region CapacityRangeModel
    /// <summary>
    /// https://reference.opcfoundation.org/v105/IA/v102/docs/7.5.2
    /// </summary>
    [UaTypeDefinition(NodeId=VariableTypes.CapacityRangeType, NamespaceUri=OpcUa.IA.Namespaces.IA)]
    public partial class CapacityRangeModel : DataItemModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="CapacityRangeModel" /> class.
        /// </summary>
        public CapacityRangeModel() : this((CapacityRangeModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CapacityRangeModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public CapacityRangeModel(CapacityRangeModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                EngineeringUnits = template.EngineeringUnits == null ? null : template.EngineeringUnits.Clone() as EUInformation;
                Resolution = template.Resolution;
            }
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// Gets or sets the value.
        /// </summary>
        [UaInstanceDeclaration(IsValue = true, NamespaceUri = OpcUa.IA.Namespaces.IA)]
        public new UnifiedAutomation.UaBase.Range Value
        {
            get {return (UnifiedAutomation.UaBase.Range) base.Value;}
            set {base.Value = value;}
        }

        /// <summary>
        /// Gets or sets the EngineeringUnits
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.OpcUa)]
        public EUInformation EngineeringUnits
        {
            get => m_EngineeringUnits;
            set => SetField(ref m_EngineeringUnits, value, nameof(EngineeringUnits));
        }
        private EUInformation m_EngineeringUnits;

        /// <summary>
        /// Gets or sets the Resolution
        /// </summary>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.IA)]
        public double Resolution
        {
            get => m_Resolution;
            set => SetField(ref m_Resolution, value, nameof(Resolution));
        }
        private double m_Resolution;


        #endregion
    }
    #endregion



}
