/******************************************************************************
**
** <auto-generated>
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.6.9, using .NET Server 3.3.0 template (version 0)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
** </auto-generated>
**
** Copyright (c) 2006-2023 Unified Automation GmbH All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** Project: .NET OPC UA SDK information model for namespace http://opcfoundation.org/UA/Machinery/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
******************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using OpcUa.DI;
using UnifiedAutomation.UaBase;
using UnifiedAutomation.UaServer;

namespace OpcUa.Machinery
{
    #region IMachineTagNameplateModel
    /// <summary>
    /// https://reference.opcfoundation.org/v104/Machinery/v101/docs/8.5
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.IMachineTagNameplateType, NamespaceUri=OpcUa.Machinery.Namespaces.Machinery)]
    public partial class IMachineTagNameplateModel : ITagNameplateModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="IMachineTagNameplateModel" /> class.
        /// </summary>
        public IMachineTagNameplateModel() : this((IMachineTagNameplateModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IMachineTagNameplateModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public IMachineTagNameplateModel(IMachineTagNameplateModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.Location != null)
                {
                    Location = template.Location.Clone() as string;
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the Location
        /// </summary>
        /// <details>
        /// To be used by end users to store the location of the machine in a scheme specific to the end user Servers shall support at least 60 Unicode characters for the clients writing this value, this means clients can expect to be able to write strings with a length of 60 Unicode characters into that field.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Machinery)]
        public string Location
        {
            get => m_Location;
            set => SetField(ref m_Location, value, nameof(Location));
        }
        private string m_Location;


        #endregion
    }
    #endregion


    #region IMachineryItemVendorNameplateModel
    /// <summary>
    /// https://reference.opcfoundation.org/v104/Machinery/v101/docs/8.2
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.IMachineryItemVendorNameplateType, NamespaceUri=OpcUa.Machinery.Namespaces.Machinery)]
    public partial class IMachineryItemVendorNameplateModel : IVendorNameplateModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="IMachineryItemVendorNameplateModel" /> class.
        /// </summary>
        public IMachineryItemVendorNameplateModel() : this((IMachineryItemVendorNameplateModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IMachineryItemVendorNameplateModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public IMachineryItemVendorNameplateModel(IMachineryItemVendorNameplateModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.InitialOperationDate != null)
                {
                    InitialOperationDate = template.InitialOperationDate;
                }
                Manufacturer = template.Manufacturer == null ? null : template.Manufacturer.Clone() as LocalizedText;
                if (template.MonthOfConstruction != null)
                {
                    MonthOfConstruction = template.MonthOfConstruction;
                }
                SerialNumber = template.SerialNumber == null ? null : template.SerialNumber.Clone() as string;
                if (template.YearOfConstruction != null)
                {
                    YearOfConstruction = template.YearOfConstruction;
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the InitialOperationDate
        /// </summary>
        /// <details>
        /// The date, when the MachineryItem was switched on the first time after it has left the manufacturer plant.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Machinery)]
        public DateTime? InitialOperationDate
        {
            get => m_InitialOperationDate;
            set => SetField(ref m_InitialOperationDate, value, nameof(InitialOperationDate));
        }
        private DateTime? m_InitialOperationDate;

        /// <summary>
        /// Gets or sets the Manufacturer
        /// </summary>
        /// <details>
        /// A human-readable, localized name of the manufacturer of the MachineryItem.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public new LocalizedText Manufacturer
        {
            get {return (LocalizedText)base.Manufacturer;}
            set {base.Manufacturer = value;}
        }

        /// <summary>
        /// Gets or sets the MonthOfConstruction
        /// </summary>
        /// <details>
        /// The month in which the manufacturing process of the MachineryItem has been completed. It shall be a number between 1 and 12, representing the month from January to December.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Machinery)]
        public byte? MonthOfConstruction
        {
            get => m_MonthOfConstruction;
            set => SetField(ref m_MonthOfConstruction, value, nameof(MonthOfConstruction));
        }
        private byte? m_MonthOfConstruction;

        /// <summary>
        /// Gets or sets the SerialNumber
        /// </summary>
        /// <details>
        /// A string containing a unique production number of the manufacturer of the MachineryItem. The global uniqueness of the serial number is only given in the context of the manufacturer, and potentially the model. The value shall not change during the life-cycle of the MachineryItem.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public new string SerialNumber
        {
            get {return (string)base.SerialNumber;}
            set {base.SerialNumber = value;}
        }

        /// <summary>
        /// Gets or sets the YearOfConstruction
        /// </summary>
        /// <details>
        /// The year (Gregorian calendar) in which the manufacturing process of the MachineryItem has been completed. It shall be a four-digit number and never change during the life-cycle of a MachineryItem.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Machinery)]
        public ushort? YearOfConstruction
        {
            get => m_YearOfConstruction;
            set => SetField(ref m_YearOfConstruction, value, nameof(YearOfConstruction));
        }
        private ushort? m_YearOfConstruction;


        #endregion
    }
    #endregion


    #region IMachineVendorNameplateModel
    /// <summary>
    /// https://reference.opcfoundation.org/v104/Machinery/v101/docs/8.4
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.IMachineVendorNameplateType, NamespaceUri=OpcUa.Machinery.Namespaces.Machinery)]
    public partial class IMachineVendorNameplateModel : IMachineryItemVendorNameplateModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="IMachineVendorNameplateModel" /> class.
        /// </summary>
        public IMachineVendorNameplateModel() : this((IMachineVendorNameplateModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IMachineVendorNameplateModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public IMachineVendorNameplateModel(IMachineVendorNameplateModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                ProductInstanceUri = template.ProductInstanceUri == null ? null : template.ProductInstanceUri.Clone() as string;
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the ProductInstanceUri
        /// </summary>
        /// <details>
        /// A globally unique resource identifier provided by the manufacturer of the machine
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public new string ProductInstanceUri
        {
            get {return (string)base.ProductInstanceUri;}
            set {base.ProductInstanceUri = value;}
        }


        #endregion
    }
    #endregion


    #region MachineryItemIdentificationModel
    /// <summary>
    /// https://reference.opcfoundation.org/v104/Machinery/v101/docs/8.3
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.MachineryItemIdentificationType, NamespaceUri=OpcUa.Machinery.Namespaces.Machinery)]
    public partial class MachineryItemIdentificationModel : FunctionalGroupModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MachineryItemIdentificationModel" /> class.
        /// </summary>
        public MachineryItemIdentificationModel() : this((MachineryItemIdentificationModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MachineryItemIdentificationModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public MachineryItemIdentificationModel(MachineryItemIdentificationModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.AssetId != null)
                {
                    AssetId = template.AssetId.Clone() as string;
                }
                if (template.ComponentName != null)
                {
                    ComponentName = template.ComponentName.Clone() as LocalizedText;
                }
                if (template.DeviceClass != null)
                {
                    DeviceClass = template.DeviceClass.Clone() as string;
                }
                if (template.HardwareRevision != null)
                {
                    HardwareRevision = template.HardwareRevision.Clone() as string;
                }
                if (template.InitialOperationDate != null)
                {
                    InitialOperationDate = template.InitialOperationDate;
                }
                Manufacturer = template.Manufacturer == null ? null : template.Manufacturer.Clone() as LocalizedText;
                if (template.ManufacturerUri != null)
                {
                    ManufacturerUri = template.ManufacturerUri.Clone() as string;
                }
                if (template.Model != null)
                {
                    Model = template.Model.Clone() as LocalizedText;
                }
                if (template.MonthOfConstruction != null)
                {
                    MonthOfConstruction = template.MonthOfConstruction;
                }
                if (template.ProductCode != null)
                {
                    ProductCode = template.ProductCode.Clone() as string;
                }
                if (template.ProductInstanceUri != null)
                {
                    ProductInstanceUri = template.ProductInstanceUri.Clone() as string;
                }
                SerialNumber = template.SerialNumber == null ? null : template.SerialNumber.Clone() as string;
                if (template.SoftwareRevision != null)
                {
                    SoftwareRevision = template.SoftwareRevision.Clone() as string;
                }
                if (template.YearOfConstruction != null)
                {
                    YearOfConstruction = template.YearOfConstruction;
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the AssetId
        /// </summary>
        /// <details>
        /// To be used by end users to store a unique identification in the context of their overall application. Servers shall support at least 40 Unicode characters for the clients writing this value, this means clients can expect to be able to write strings with a length of 40 Unicode characters into that field.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public string AssetId
        {
            get => m_AssetId;
            set => SetField(ref m_AssetId, value, nameof(AssetId));
        }
        private string m_AssetId;

        /// <summary>
        /// Gets or sets the ComponentName
        /// </summary>
        /// <details>
        /// To be used by end users to store a human-readable localized text for the MachineryItem. The minimum number of locales supported for this property shall be two. Servers shall support at least 40 Unicode characters for the clients writing the text part of each locale, this means clients can expect to be able to write texts with a length of 40 Unicode characters into that field.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public LocalizedText ComponentName
        {
            get => m_ComponentName;
            set => SetField(ref m_ComponentName, value, nameof(ComponentName));
        }
        private LocalizedText m_ComponentName;

        /// <summary>
        /// Gets or sets the DeviceClass
        /// </summary>
        /// <details>
        /// Indicates in which domain or for what purpose the MachineryItem is used.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public string DeviceClass
        {
            get => m_DeviceClass;
            set => SetField(ref m_DeviceClass, value, nameof(DeviceClass));
        }
        private string m_DeviceClass;

        /// <summary>
        /// Gets or sets the HardwareRevision
        /// </summary>
        /// <details>
        /// A string representation of the revision level of the hardware of a MachineryItem. Hardware is physical equipment, as opposed to programs, procedures, rules and associated documentation. Many machines will not provide such information due to the modular and configurable nature of the machine.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public string HardwareRevision
        {
            get => m_HardwareRevision;
            set => SetField(ref m_HardwareRevision, value, nameof(HardwareRevision));
        }
        private string m_HardwareRevision;

        /// <summary>
        /// Gets or sets the InitialOperationDate
        /// </summary>
        /// <details>
        /// The date, when the MachineryItem was switched on the first time after it has left the manufacturer plant.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Machinery)]
        public DateTime? InitialOperationDate
        {
            get => m_InitialOperationDate;
            set => SetField(ref m_InitialOperationDate, value, nameof(InitialOperationDate));
        }
        private DateTime? m_InitialOperationDate;

        /// <summary>
        /// Gets or sets the Manufacturer
        /// </summary>
        /// <details>
        /// A human-readable, localized name of the manufacturer of the MachineryItem.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public LocalizedText Manufacturer
        {
            get => m_Manufacturer;
            set => SetField(ref m_Manufacturer, value, nameof(Manufacturer));
        }
        private LocalizedText m_Manufacturer;

        /// <summary>
        /// Gets or sets the ManufacturerUri
        /// </summary>
        /// <details>
        /// A globally unique identifier of the manufacturer of the MachineryItem.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public string ManufacturerUri
        {
            get => m_ManufacturerUri;
            set => SetField(ref m_ManufacturerUri, value, nameof(ManufacturerUri));
        }
        private string m_ManufacturerUri;

        /// <summary>
        /// Gets or sets the Model
        /// </summary>
        /// <details>
        /// A human-readable, localized name of the model of the MachineryItem.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public LocalizedText Model
        {
            get => m_Model;
            set => SetField(ref m_Model, value, nameof(Model));
        }
        private LocalizedText m_Model;

        /// <summary>
        /// Gets or sets the MonthOfConstruction
        /// </summary>
        /// <details>
        /// The month in which the manufacturing process of the MachineryItem has been completed. It shall be a number between 1 and 12, representing the month from January to December.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Machinery)]
        public byte? MonthOfConstruction
        {
            get => m_MonthOfConstruction;
            set => SetField(ref m_MonthOfConstruction, value, nameof(MonthOfConstruction));
        }
        private byte? m_MonthOfConstruction;

        /// <summary>
        /// Gets or sets the ProductCode
        /// </summary>
        /// <details>
        /// A machine-readable string of the model of the MachineryItem, that might include options like the hardware configuration of the model. This information might be provided by the ERP system of the vendor. For example, it can be used as order information.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public string ProductCode
        {
            get => m_ProductCode;
            set => SetField(ref m_ProductCode, value, nameof(ProductCode));
        }
        private string m_ProductCode;

        /// <summary>
        /// Gets or sets the ProductInstanceUri
        /// </summary>
        /// <details>
        /// A globally unique resource identifier provided by the manufacturer of the MachineryItem.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public string ProductInstanceUri
        {
            get => m_ProductInstanceUri;
            set => SetField(ref m_ProductInstanceUri, value, nameof(ProductInstanceUri));
        }
        private string m_ProductInstanceUri;

        /// <summary>
        /// Gets or sets the SerialNumber
        /// </summary>
        /// <details>
        /// A string containing a unique production number of the manufacturer of the MachineryItem. The global uniqueness of the serial number is only given in the context of the manufacturer, and potentially the model. The value shall not change during the life-cycle of the MachineryItem.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public string SerialNumber
        {
            get => m_SerialNumber;
            set => SetField(ref m_SerialNumber, value, nameof(SerialNumber));
        }
        private string m_SerialNumber;

        /// <summary>
        /// Gets or sets the SoftwareRevision
        /// </summary>
        /// <details>
        /// A string representation of the revision level of a MachineryItem. In most cases, MachineryItems consist of several software components. In that case, information about the software components might be provided as additional information in the address space, including individual revision information. In that case, this property is either not provided or provides an overall software revision level. The value might change during the life-cycle of a MachineryItem.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public string SoftwareRevision
        {
            get => m_SoftwareRevision;
            set => SetField(ref m_SoftwareRevision, value, nameof(SoftwareRevision));
        }
        private string m_SoftwareRevision;

        /// <summary>
        /// Gets or sets the YearOfConstruction
        /// </summary>
        /// <details>
        /// The year (Gregorian calendar) in which the manufacturing process of the MachineryItem has been completed. It shall be a four-digit number and never change during the life-cycle of a MachineryItem.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Machinery)]
        public ushort? YearOfConstruction
        {
            get => m_YearOfConstruction;
            set => SetField(ref m_YearOfConstruction, value, nameof(YearOfConstruction));
        }
        private ushort? m_YearOfConstruction;


        #endregion
    }
    #endregion


    #region MachineIdentificationModel
    /// <summary>
    /// https://reference.opcfoundation.org/v104/Machinery/v101/docs/8.6
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.MachineIdentificationType, NamespaceUri=OpcUa.Machinery.Namespaces.Machinery)]
    public partial class MachineIdentificationModel : MachineryItemIdentificationModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MachineIdentificationModel" /> class.
        /// </summary>
        public MachineIdentificationModel() : this((MachineIdentificationModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MachineIdentificationModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public MachineIdentificationModel(MachineIdentificationModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.Location != null)
                {
                    Location = template.Location.Clone() as string;
                }
                ProductInstanceUri = template.ProductInstanceUri == null ? null : template.ProductInstanceUri.Clone() as string;
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the Location
        /// </summary>
        /// <details>
        /// To be used by end users to store the location of the machine in a scheme specific to the end user. Servers shall support at least 60 Unicode characters for the clients writing this value, this means clients can expect to be able to write strings with a length of 60 Unicode characters into that field.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.Machinery)]
        public string Location
        {
            get => m_Location;
            set => SetField(ref m_Location, value, nameof(Location));
        }
        private string m_Location;

        /// <summary>
        /// Gets or sets the ProductInstanceUri
        /// </summary>
        /// <details>
        /// A globally unique resource identifier provided by the manufacturer of the machine
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public new string ProductInstanceUri
        {
            get {return (string)base.ProductInstanceUri;}
            set {base.ProductInstanceUri = value;}
        }


        #endregion
    }
    #endregion


    #region MachineryComponentIdentificationModel
    /// <summary>
    /// https://reference.opcfoundation.org/v104/Machinery/v101/docs/10.2
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.MachineryComponentIdentificationType, NamespaceUri=OpcUa.Machinery.Namespaces.Machinery)]
    public partial class MachineryComponentIdentificationModel : MachineryItemIdentificationModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MachineryComponentIdentificationModel" /> class.
        /// </summary>
        public MachineryComponentIdentificationModel() : this((MachineryComponentIdentificationModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MachineryComponentIdentificationModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public MachineryComponentIdentificationModel(MachineryComponentIdentificationModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
                if (template.DeviceRevision != null)
                {
                    DeviceRevision = template.DeviceRevision.Clone() as string;
                }
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the DeviceRevision
        /// </summary>
        /// <details>
        /// A string representation of the overall revision level of the component. Often, it is increased when either the SoftwareRevision and / or the HardwareRevision of the component is increased. As an example, it can be used in ERP systems together with the ProductCode.
        /// </details>
        [UaInstanceDeclaration(NamespaceUri = Namespaces.DI)]
        public string DeviceRevision
        {
            get => m_DeviceRevision;
            set => SetField(ref m_DeviceRevision, value, nameof(DeviceRevision));
        }
        private string m_DeviceRevision;


        #endregion
    }
    #endregion


    #region MachineComponentsModel
    /// <summary>
    /// https://reference.opcfoundation.org/v104/Machinery/v101/docs/11.2
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.MachineComponentsType, NamespaceUri=OpcUa.Machinery.Namespaces.Machinery)]
    public partial class MachineComponentsModel : BaseObjectModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MachineComponentsModel" /> class.
        /// </summary>
        public MachineComponentsModel() : this((MachineComponentsModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MachineComponentsModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public MachineComponentsModel(MachineComponentsModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
            }
        }
        #endregion

        #region Public Properties

        #endregion
    }
    #endregion


    #region MachineryItemState_StateMachineModel
    /// <summary>
    /// https://reference.opcfoundation.org/v104/Machinery/v101/docs/12.2
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.MachineryItemState_StateMachineType, NamespaceUri=OpcUa.Machinery.Namespaces.Machinery)]
    public partial class MachineryItemState_StateMachineModel : FiniteStateMachineModel, IActivatableModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MachineryItemState_StateMachineModel" /> class.
        /// </summary>
        public MachineryItemState_StateMachineModel() : this((MachineryItemState_StateMachineModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MachineryItemState_StateMachineModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public MachineryItemState_StateMachineModel(MachineryItemState_StateMachineModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
            }
        }
        #endregion

        #region Public Properties

        #endregion

        #region FiniteStateMachine
        /// <summary>
        /// The current state of the state machine.
        /// </summary>
        protected State? m_state;

        /// <summary>
        /// The last transition of the state machine.
        /// </summary>
        protected Transition? m_transition;

        /// <summary>
        /// The enumeration representing the possible states of the state machine.
        /// </summary>
        public enum State : uint
        {
            /// <summary>
            /// The OutOfService state.
            /// </summary>
            OutOfService = 1,
            /// <summary>
            /// The NotAvailable state.
            /// </summary>
            NotAvailable = 0,
            /// <summary>
            /// The Executing state.
            /// </summary>
            Executing = 3,
            /// <summary>
            /// The NotExecuting state.
            /// </summary>
            NotExecuting = 2,
        }

        /// <summary>
        /// The enumeration representing the possible transitions of the state machine.
        /// </summary>
        public enum Transition : uint
        {
            /// <summary>
            /// Transition from <see cref="State.Executing"/> to <see cref="State.Executing"/>.
            /// </summary>
            FromExecutingToExecuting = 14,
            /// <summary>
            /// Transition from <see cref="State.Executing"/> to <see cref="State.NotAvailable"/>.
            /// </summary>
            FromExecutingToNotAvailable = 6,
            /// <summary>
            /// Transition from <see cref="State.Executing"/> to <see cref="State.NotExecuting"/>.
            /// </summary>
            FromExecutingToNotExecuting = 8,
            /// <summary>
            /// Transition from <see cref="State.Executing"/> to <see cref="State.OutOfService"/>.
            /// </summary>
            FromExecutingToOutOfService = 7,
            /// <summary>
            /// Transition from <see cref="State.NotAvailable"/> to <see cref="State.Executing"/>.
            /// </summary>
            FromNotAvailableToExecuting = 1,
            /// <summary>
            /// Transition from <see cref="State.NotAvailable"/> to <see cref="State.NotAvailable"/>.
            /// </summary>
            FromNotAvailableToNotAvailable = 12,
            /// <summary>
            /// Transition from <see cref="State.NotAvailable"/> to <see cref="State.NotExecuting"/>.
            /// </summary>
            FromNotAvailableToNotExecuting = 2,
            /// <summary>
            /// Transition from <see cref="State.NotAvailable"/> to <see cref="State.OutOfService"/>.
            /// </summary>
            FromNotAvailableToOutOfService = 0,
            /// <summary>
            /// Transition from <see cref="State.NotExecuting"/> to <see cref="State.Executing"/>.
            /// </summary>
            FromNotExecutingToExecuting = 11,
            /// <summary>
            /// Transition from <see cref="State.NotExecuting"/> to <see cref="State.NotAvailable"/>.
            /// </summary>
            FromNotExecutingToNotAvailable = 9,
            /// <summary>
            /// Transition from <see cref="State.NotExecuting"/> to <see cref="State.NotExecuting"/>.
            /// </summary>
            FromNotExecutingToNotExecuting = 15,
            /// <summary>
            /// Transition from <see cref="State.NotExecuting"/> to <see cref="State.OutOfService"/>.
            /// </summary>
            FromNotExecutingToOutOfService = 10,
            /// <summary>
            /// Transition from <see cref="State.OutOfService"/> to <see cref="State.Executing"/>.
            /// </summary>
            FromOutOfServiceToExecuting = 4,
            /// <summary>
            /// Transition from <see cref="State.OutOfService"/> to <see cref="State.NotAvailable"/>.
            /// </summary>
            FromOutOfServiceToNotAvailable = 3,
            /// <summary>
            /// Transition from <see cref="State.OutOfService"/> to <see cref="State.NotExecuting"/>.
            /// </summary>
            FromOutOfServiceToNotExecuting = 5,
            /// <summary>
            /// Transition from <see cref="State.OutOfService"/> to <see cref="State.OutOfService"/>.
            /// </summary>
            FromOutOfServiceToOutOfService = 13,
        }

        /// <summary>
        /// The <see cref="FiniteStateMachineModel.CurrentState"/> as the enumeration value.
        /// </summary>
        public State? InternalState
        {
            get => m_state;
            protected set
            {
                m_state = value;
                if (CurrentState != null)
                {
                    if (m_state.HasValue)
                    {
                        State s = m_state.Value;

                        CurrentState.Value = GetLocalizedText(s);
                        CurrentState.Number = (uint)s;
                        if (NamespaceTable != null)
                        {
                            CurrentState.Name = GetName(s).ToQualifiedName(NamespaceTable);
                            CurrentState.Id = GetExpandedNodeId(s).ToNodeId(NamespaceTable);
                        }
                        CurrentState.SetStatusCode(nameof(CurrentState.Value), StatusCodes.Good);
                    }
                    else
                    {
                        CurrentState.Value = default;
                        CurrentState.Name = default;
                        CurrentState.Number = default;
                        CurrentState.Id = default;
                        CurrentState.SetStatusCode(nameof(CurrentState.Value), StatusCodes.BadStateNotActive);
                    }
                }
            }
        }

        /// <summary>
        /// The <see cref="FiniteStateMachineModel.LastTransition"/> as the enumeration value.
        /// </summary>
        public Transition? InternalTransition
        {
            get => m_transition;
            protected set
            {
                m_transition = value;
                if (LastTransition != null)
                {
                    if (m_transition.HasValue)
                    {
                        Transition t = m_transition.Value;

                        LastTransition.Value = GetLocalizedText(t);
                        LastTransition.Number = (uint)t;
                        LastTransition.TransitionTime = DateTime.UtcNow;
                        if (NamespaceTable != null)
                        {
                            LastTransition.Name = GetName(t).ToQualifiedName(NamespaceTable);
                            LastTransition.Id = GetExpandedNodeId(t).ToNodeId(NamespaceTable);
                        }
                    }
                    else
                    {
                        LastTransition.Value = default;
                        LastTransition.Name = default;
                        LastTransition.Number = default;
                        LastTransition.Id = default;
                        LastTransition.TransitionTime = default;
                    }
                }
            }
        }

        /// <summary>
        /// Occurs when the <see cref="SwitchToState" /> method was called.
        /// </summary>
        /// <remarks>
        /// Note, the event is also emitted when the state stays the same.
        /// </remarks>
        public event EventHandler<StateMachineEventArgs<State?, Transition?>> Switched;

        /// <summary>
        /// Raises the <see cref="Switched" /> event.
        /// </summary>
        public void RaiseSwitchedEvent(State? oldState, State? state, Transition? transition)
        {
            var handle = Switched;
            if (handle != null)
            {
                var args = new StateMachineEventArgs<State?, Transition?>(oldState, state, transition);
                Switched?.Invoke(this, args);
            }
        }

        /// <remarks />
        public NamespaceTable NamespaceTable { get; set; }

        /// <remarks />
        public virtual void ActivateModel(RequestContext context)
        {
            NamespaceTable = context.NamespaceUris;

            // reset state and transition with the now available Ids
            InternalState = m_state;
            InternalTransition = m_transition;
        }

        /// <remarks />
        public virtual void DeactivateModel()
        {
        }

        /// <summary>
        /// Switch to the given state.
        /// </summary>
        /// <param name="state">The state.</param>
        /// <param name="transition">The transition.</param>
        /// <remarks>
        /// If the transition value is <c>null</c> the method will take the first
        /// transition that is possible. If there is no possible transition or
        /// if a transition was passed that is not possible for the old and new
        /// state combination, <c>null</c> will be assigned to the
        /// <see cref="InternalTransition"/> and <see cref="FiniteStateMachineModel.LastTransition"/> properties.
        /// It is up to the caller to avoid such situations.
        ///
        /// A <c>null</c> value for the state will be translated to the specification
        /// conform status code <see cref="StatusCodes.BadStateNotActive"/>.
        /// </remarks>
        public virtual void SwitchToState(State? state, Transition? transition = null)
        {
            State? oldState = InternalState;

            if (oldState.HasValue && state.HasValue)
            {
                var transitions = GetTransitions(oldState.Value, state.Value);
                if (transition.HasValue)
                {
                    var tvalue = transition.Value;
                    transitions = transitions.Where(t => t == tvalue);
                }

                transition = transitions
                    .Cast<Transition?>()
                    .FirstOrDefault();
            }

            InternalState = state;
            InternalTransition = transition;

            RaiseSwitchedEvent(oldState, state, transition);
        }

        /// <summary>
        /// A sequence of all possible transition for the given states.
        /// </summary>
        /// <param name="oldState">The <em>From</em> state.</param>
        /// <param name="newState">The <em>To</em> state.</param>
        /// <returns>
        /// A sequence of all possible transition for the given states. The sequence
        /// can be empty, but it will never be null.
        /// </returns>
        public static IEnumerable<Transition> GetTransitions(State oldState, State newState)
        {
            switch (oldState)
            {
                case State.OutOfService:
                    if (newState is State.Executing)
                    {
                        yield return Transition.FromOutOfServiceToExecuting;
                    }
                    if (newState is State.NotAvailable)
                    {
                        yield return Transition.FromOutOfServiceToNotAvailable;
                    }
                    if (newState is State.NotExecuting)
                    {
                        yield return Transition.FromOutOfServiceToNotExecuting;
                    }
                    if (newState is State.OutOfService)
                    {
                        yield return Transition.FromOutOfServiceToOutOfService;
                    }
                    break;
                case State.NotAvailable:
                    if (newState is State.Executing)
                    {
                        yield return Transition.FromNotAvailableToExecuting;
                    }
                    if (newState is State.NotAvailable)
                    {
                        yield return Transition.FromNotAvailableToNotAvailable;
                    }
                    if (newState is State.NotExecuting)
                    {
                        yield return Transition.FromNotAvailableToNotExecuting;
                    }
                    if (newState is State.OutOfService)
                    {
                        yield return Transition.FromNotAvailableToOutOfService;
                    }
                    break;
                case State.Executing:
                    if (newState is State.Executing)
                    {
                        yield return Transition.FromExecutingToExecuting;
                    }
                    if (newState is State.NotAvailable)
                    {
                        yield return Transition.FromExecutingToNotAvailable;
                    }
                    if (newState is State.NotExecuting)
                    {
                        yield return Transition.FromExecutingToNotExecuting;
                    }
                    if (newState is State.OutOfService)
                    {
                        yield return Transition.FromExecutingToOutOfService;
                    }
                    break;
                case State.NotExecuting:
                    if (newState is State.Executing)
                    {
                        yield return Transition.FromNotExecutingToExecuting;
                    }
                    if (newState is State.NotAvailable)
                    {
                        yield return Transition.FromNotExecutingToNotAvailable;
                    }
                    if (newState is State.NotExecuting)
                    {
                        yield return Transition.FromNotExecutingToNotExecuting;
                    }
                    if (newState is State.OutOfService)
                    {
                        yield return Transition.FromNotExecutingToOutOfService;
                    }
                    break;
            }
        }

        /// <summary>
        /// Retrieves a <see cref="LocalizedText"/> for the given state
        /// value.
        /// </summary>
        /// <param name="state">The state to get the text.</param>
        /// <returns>The text.</returns>
        public static LocalizedText GetLocalizedText(State state)
        {
            string text = state.ToString();
            return new LocalizedText(text, "", text);
        }

        /// <summary>
        /// Retrieves a <see cref="AbsoluteName"/> for the given state
        /// value.
        /// </summary>
        /// <param name="state">The state to get the name.</param>
        /// <returns>The name.</returns>
        public static AbsoluteName GetName(State state)
        {
            if (s_stateNames.TryGetValue(state, out var value))
            {
                return value;
            }

            return null;
        }

        /// <summary>
        /// Retrieves the <see cref="ExpandedNodeId"/> for the given state
        /// value.
        /// </summary>
        /// <param name="state">The state to get the ExpandedNodeId.</param>
        /// <returns>The ExpandedNodeId.</returns>
        public static ExpandedNodeId GetExpandedNodeId(State state)
        {
            if (s_stateNodeIds.TryGetValue(state, out var value))
            {
                return value;
            }

            return null;
        }

        private static readonly IDictionary<State, AbsoluteName> s_stateNames = new Dictionary<State, AbsoluteName>()
        {
            { State.OutOfService, new AbsoluteName(BrowseNames.OutOfService, Namespaces.Machinery) },
            { State.NotAvailable, new AbsoluteName(BrowseNames.NotAvailable, Namespaces.Machinery) },
            { State.Executing, new AbsoluteName(BrowseNames.Executing, Namespaces.Machinery) },
            { State.NotExecuting, new AbsoluteName(BrowseNames.NotExecuting, Namespaces.Machinery) },
        };

        private static readonly IDictionary<State, ExpandedNodeId> s_stateNodeIds = new Dictionary<State, ExpandedNodeId>()
        {
            { State.OutOfService, ObjectIds.MachineryItemState_StateMachineType_OutOfService },
            { State.NotAvailable, ObjectIds.MachineryItemState_StateMachineType_NotAvailable },
            { State.Executing, ObjectIds.MachineryItemState_StateMachineType_Executing },
            { State.NotExecuting, ObjectIds.MachineryItemState_StateMachineType_NotExecuting },
        };

        /// <summary>
        /// Retrieves a <see cref="LocalizedText"/> for the given transition
        /// value.
        /// </summary>
        /// <param name="transition">The transition to get the text.</param>
        /// <returns>The transition.</returns>
        public static LocalizedText GetLocalizedText(Transition transition)
        {
            string text = transition.ToString();
            return new LocalizedText(text, "", text);
        }

        /// <summary>
        /// Retrieves a <see cref="AbsoluteName"/> for the given transition
        /// value.
        /// </summary>
        /// <param name="transition">The transition to get the name.</param>
        /// <returns>The name.</returns>
        public static AbsoluteName GetName(Transition transition)
        {
            if (s_transitionNames.TryGetValue(transition, out var value))
            {
                return value;
            }

            return null;
        }

        /// <summary>
        /// Retrieves the <see cref="ExpandedNodeId"/> for the given transition
        /// value.
        /// </summary>
        /// <param name="transition">The transition to get the ExpandedNodeId.</param>
        /// <returns>The NodeId.</returns>
        public static ExpandedNodeId GetExpandedNodeId(Transition transition)
        {
            if (s_transitionNodeIds.TryGetValue(transition, out var value))
            {
                return value;
            }

            return null;
        }

        private static readonly IDictionary<Transition, AbsoluteName> s_transitionNames = new Dictionary<Transition, AbsoluteName>()
        {
            { Transition.FromExecutingToExecuting, new AbsoluteName(BrowseNames.FromExecutingToExecuting, Namespaces.Machinery) },
            { Transition.FromExecutingToNotAvailable, new AbsoluteName(BrowseNames.FromExecutingToNotAvailable, Namespaces.Machinery) },
            { Transition.FromExecutingToNotExecuting, new AbsoluteName(BrowseNames.FromExecutingToNotExecuting, Namespaces.Machinery) },
            { Transition.FromExecutingToOutOfService, new AbsoluteName(BrowseNames.FromExecutingToOutOfService, Namespaces.Machinery) },
            { Transition.FromNotAvailableToExecuting, new AbsoluteName(BrowseNames.FromNotAvailableToExecuting, Namespaces.Machinery) },
            { Transition.FromNotAvailableToNotAvailable, new AbsoluteName(BrowseNames.FromNotAvailableToNotAvailable, Namespaces.Machinery) },
            { Transition.FromNotAvailableToNotExecuting, new AbsoluteName(BrowseNames.FromNotAvailableToNotExecuting, Namespaces.Machinery) },
            { Transition.FromNotAvailableToOutOfService, new AbsoluteName(BrowseNames.FromNotAvailableToOutOfService, Namespaces.Machinery) },
            { Transition.FromNotExecutingToExecuting, new AbsoluteName(BrowseNames.FromNotExecutingToExecuting, Namespaces.Machinery) },
            { Transition.FromNotExecutingToNotAvailable, new AbsoluteName(BrowseNames.FromNotExecutingToNotAvailable, Namespaces.Machinery) },
            { Transition.FromNotExecutingToNotExecuting, new AbsoluteName(BrowseNames.FromNotExecutingToNotExecuting, Namespaces.Machinery) },
            { Transition.FromNotExecutingToOutOfService, new AbsoluteName(BrowseNames.FromNotExecutingToOutOfService, Namespaces.Machinery) },
            { Transition.FromOutOfServiceToExecuting, new AbsoluteName(BrowseNames.FromOutOfServiceToExecuting, Namespaces.Machinery) },
            { Transition.FromOutOfServiceToNotAvailable, new AbsoluteName(BrowseNames.FromOutOfServiceToNotAvailable, Namespaces.Machinery) },
            { Transition.FromOutOfServiceToNotExecuting, new AbsoluteName(BrowseNames.FromOutOfServiceToNotExecuting, Namespaces.Machinery) },
            { Transition.FromOutOfServiceToOutOfService, new AbsoluteName(BrowseNames.FromOutOfServiceToOutOfService, Namespaces.Machinery) },
        };

        private static readonly IDictionary<Transition, ExpandedNodeId> s_transitionNodeIds = new Dictionary<Transition, ExpandedNodeId>()
        {
            { Transition.FromExecutingToExecuting, ObjectIds.MachineryItemState_StateMachineType_FromExecutingToExecuting },
            { Transition.FromExecutingToNotAvailable, ObjectIds.MachineryItemState_StateMachineType_FromExecutingToNotAvailable },
            { Transition.FromExecutingToNotExecuting, ObjectIds.MachineryItemState_StateMachineType_FromExecutingToNotExecuting },
            { Transition.FromExecutingToOutOfService, ObjectIds.MachineryItemState_StateMachineType_FromExecutingToOutOfService },
            { Transition.FromNotAvailableToExecuting, ObjectIds.MachineryItemState_StateMachineType_FromNotAvailableToExecuting },
            { Transition.FromNotAvailableToNotAvailable, ObjectIds.MachineryItemState_StateMachineType_FromNotAvailableToNotAvailable },
            { Transition.FromNotAvailableToNotExecuting, ObjectIds.MachineryItemState_StateMachineType_FromNotAvailableToNotExecuting },
            { Transition.FromNotAvailableToOutOfService, ObjectIds.MachineryItemState_StateMachineType_FromNotAvailableToOutOfService },
            { Transition.FromNotExecutingToExecuting, ObjectIds.MachineryItemState_StateMachineType_FromNotExecutingToExecuting },
            { Transition.FromNotExecutingToNotAvailable, ObjectIds.MachineryItemState_StateMachineType_FromNotExecutingToNotAvailable },
            { Transition.FromNotExecutingToNotExecuting, ObjectIds.MachineryItemState_StateMachineType_FromNotExecutingToNotExecuting },
            { Transition.FromNotExecutingToOutOfService, ObjectIds.MachineryItemState_StateMachineType_FromNotExecutingToOutOfService },
            { Transition.FromOutOfServiceToExecuting, ObjectIds.MachineryItemState_StateMachineType_FromOutOfServiceToExecuting },
            { Transition.FromOutOfServiceToNotAvailable, ObjectIds.MachineryItemState_StateMachineType_FromOutOfServiceToNotAvailable },
            { Transition.FromOutOfServiceToNotExecuting, ObjectIds.MachineryItemState_StateMachineType_FromOutOfServiceToNotExecuting },
            { Transition.FromOutOfServiceToOutOfService, ObjectIds.MachineryItemState_StateMachineType_FromOutOfServiceToOutOfService },
        };
        #endregion

    }
    #endregion


    #region MachineryOperationModeStateMachineModel
    /// <summary>
    /// https://reference.opcfoundation.org/v104/Machinery/v101/docs/13.2
    /// </summary>
    [UaTypeDefinition(NodeId=ObjectTypes.MachineryOperationModeStateMachineType, NamespaceUri=OpcUa.Machinery.Namespaces.Machinery)]
    public partial class MachineryOperationModeStateMachineModel : FiniteStateMachineModel, IActivatableModel
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MachineryOperationModeStateMachineModel" /> class.
        /// </summary>
        public MachineryOperationModeStateMachineModel() : this((MachineryOperationModeStateMachineModel)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MachineryOperationModeStateMachineModel" /> class.
        /// </summary>
        /// <param name="template">The template.</param>
        /// <param name="dummy">Dummy argument to enable writing own constructors that are called by the generated code.</param>
        public MachineryOperationModeStateMachineModel(MachineryOperationModeStateMachineModel template, DummyArgument dummy = null) : base(template)
        {
            if (template == null)
            {
            }
            else
            {
            }
        }
        #endregion

        #region Public Properties

        #endregion

        #region FiniteStateMachine
        /// <summary>
        /// The current state of the state machine.
        /// </summary>
        protected State? m_state;

        /// <summary>
        /// The last transition of the state machine.
        /// </summary>
        protected Transition? m_transition;

        /// <summary>
        /// The enumeration representing the possible states of the state machine.
        /// </summary>
        public enum State : uint
        {
            /// <summary>
            /// The None state.
            /// </summary>
            None = 0,
            /// <summary>
            /// The Maintenance state.
            /// </summary>
            Maintenance = 1,
            /// <summary>
            /// The Processing state.
            /// </summary>
            Processing = 3,
            /// <summary>
            /// The Setup state.
            /// </summary>
            Setup = 2,
        }

        /// <summary>
        /// The enumeration representing the possible transitions of the state machine.
        /// </summary>
        public enum Transition : uint
        {
            /// <summary>
            /// Transition from <see cref="State.Maintenance"/> to <see cref="State.Maintenance"/>.
            /// </summary>
            FromMaintenanceToMaintenance = 13,
            /// <summary>
            /// Transition from <see cref="State.Maintenance"/> to <see cref="State.None"/>.
            /// </summary>
            FromMaintenanceToNone = 3,
            /// <summary>
            /// Transition from <see cref="State.Maintenance"/> to <see cref="State.Processing"/>.
            /// </summary>
            FromMaintenanceToProcessing = 4,
            /// <summary>
            /// Transition from <see cref="State.Maintenance"/> to <see cref="State.Setup"/>.
            /// </summary>
            FromMaintenanceToSetup = 5,
            /// <summary>
            /// Transition from <see cref="State.None"/> to <see cref="State.Maintenance"/>.
            /// </summary>
            FromNoneToMaintenance = 0,
            /// <summary>
            /// Transition from <see cref="State.None"/> to <see cref="State.None"/>.
            /// </summary>
            FromNoneToNone = 12,
            /// <summary>
            /// Transition from <see cref="State.None"/> to <see cref="State.Processing"/>.
            /// </summary>
            FromNoneToProcessing = 1,
            /// <summary>
            /// Transition from <see cref="State.None"/> to <see cref="State.Setup"/>.
            /// </summary>
            FromNoneToSetup = 2,
            /// <summary>
            /// Transition from <see cref="State.Processing"/> to <see cref="State.Maintenance"/>.
            /// </summary>
            FromProcessingToMaintenance = 7,
            /// <summary>
            /// Transition from <see cref="State.Processing"/> to <see cref="State.None"/>.
            /// </summary>
            FromProcessingToNone = 6,
            /// <summary>
            /// Transition from <see cref="State.Processing"/> to <see cref="State.Processing"/>.
            /// </summary>
            FromProcessingToProcessing = 14,
            /// <summary>
            /// Transition from <see cref="State.Processing"/> to <see cref="State.Setup"/>.
            /// </summary>
            FromProcessingToSetup = 8,
            /// <summary>
            /// Transition from <see cref="State.Setup"/> to <see cref="State.Maintenance"/>.
            /// </summary>
            FromSetupToMaintenance = 10,
            /// <summary>
            /// Transition from <see cref="State.Setup"/> to <see cref="State.None"/>.
            /// </summary>
            FromSetupToNone = 9,
            /// <summary>
            /// Transition from <see cref="State.Setup"/> to <see cref="State.Processing"/>.
            /// </summary>
            FromSetupToProcessing = 11,
            /// <summary>
            /// Transition from <see cref="State.Setup"/> to <see cref="State.Setup"/>.
            /// </summary>
            FromSetupToSetup = 15,
        }

        /// <summary>
        /// The <see cref="FiniteStateMachineModel.CurrentState"/> as the enumeration value.
        /// </summary>
        public State? InternalState
        {
            get => m_state;
            protected set
            {
                m_state = value;
                if (CurrentState != null)
                {
                    if (m_state.HasValue)
                    {
                        State s = m_state.Value;

                        CurrentState.Value = GetLocalizedText(s);
                        CurrentState.Number = (uint)s;
                        if (NamespaceTable != null)
                        {
                            CurrentState.Name = GetName(s).ToQualifiedName(NamespaceTable);
                            CurrentState.Id = GetExpandedNodeId(s).ToNodeId(NamespaceTable);
                        }
                        CurrentState.SetStatusCode(nameof(CurrentState.Value), StatusCodes.Good);
                    }
                    else
                    {
                        CurrentState.Value = default;
                        CurrentState.Name = default;
                        CurrentState.Number = default;
                        CurrentState.Id = default;
                        CurrentState.SetStatusCode(nameof(CurrentState.Value), StatusCodes.BadStateNotActive);
                    }
                }
            }
        }

        /// <summary>
        /// The <see cref="FiniteStateMachineModel.LastTransition"/> as the enumeration value.
        /// </summary>
        public Transition? InternalTransition
        {
            get => m_transition;
            protected set
            {
                m_transition = value;
                if (LastTransition != null)
                {
                    if (m_transition.HasValue)
                    {
                        Transition t = m_transition.Value;

                        LastTransition.Value = GetLocalizedText(t);
                        LastTransition.Number = (uint)t;
                        LastTransition.TransitionTime = DateTime.UtcNow;
                        if (NamespaceTable != null)
                        {
                            LastTransition.Name = GetName(t).ToQualifiedName(NamespaceTable);
                            LastTransition.Id = GetExpandedNodeId(t).ToNodeId(NamespaceTable);
                        }
                    }
                    else
                    {
                        LastTransition.Value = default;
                        LastTransition.Name = default;
                        LastTransition.Number = default;
                        LastTransition.Id = default;
                        LastTransition.TransitionTime = default;
                    }
                }
            }
        }

        /// <summary>
        /// Occurs when the <see cref="SwitchToState" /> method was called.
        /// </summary>
        /// <remarks>
        /// Note, the event is also emitted when the state stays the same.
        /// </remarks>
        public event EventHandler<StateMachineEventArgs<State?, Transition?>> Switched;

        /// <summary>
        /// Raises the <see cref="Switched" /> event.
        /// </summary>
        public void RaiseSwitchedEvent(State? oldState, State? state, Transition? transition)
        {
            var handle = Switched;
            if (handle != null)
            {
                var args = new StateMachineEventArgs<State?, Transition?>(oldState, state, transition);
                Switched?.Invoke(this, args);
            }
        }

        /// <remarks />
        public NamespaceTable NamespaceTable { get; set; }

        /// <remarks />
        public virtual void ActivateModel(RequestContext context)
        {
            NamespaceTable = context.NamespaceUris;

            // reset state and transition with the now available Ids
            InternalState = m_state;
            InternalTransition = m_transition;
        }

        /// <remarks />
        public virtual void DeactivateModel()
        {
        }

        /// <summary>
        /// Switch to the given state.
        /// </summary>
        /// <param name="state">The state.</param>
        /// <param name="transition">The transition.</param>
        /// <remarks>
        /// If the transition value is <c>null</c> the method will take the first
        /// transition that is possible. If there is no possible transition or
        /// if a transition was passed that is not possible for the old and new
        /// state combination, <c>null</c> will be assigned to the
        /// <see cref="InternalTransition"/> and <see cref="FiniteStateMachineModel.LastTransition"/> properties.
        /// It is up to the caller to avoid such situations.
        ///
        /// A <c>null</c> value for the state will be translated to the specification
        /// conform status code <see cref="StatusCodes.BadStateNotActive"/>.
        /// </remarks>
        public virtual void SwitchToState(State? state, Transition? transition = null)
        {
            State? oldState = InternalState;

            if (oldState.HasValue && state.HasValue)
            {
                var transitions = GetTransitions(oldState.Value, state.Value);
                if (transition.HasValue)
                {
                    var tvalue = transition.Value;
                    transitions = transitions.Where(t => t == tvalue);
                }

                transition = transitions
                    .Cast<Transition?>()
                    .FirstOrDefault();
            }

            InternalState = state;
            InternalTransition = transition;

            RaiseSwitchedEvent(oldState, state, transition);
        }

        /// <summary>
        /// A sequence of all possible transition for the given states.
        /// </summary>
        /// <param name="oldState">The <em>From</em> state.</param>
        /// <param name="newState">The <em>To</em> state.</param>
        /// <returns>
        /// A sequence of all possible transition for the given states. The sequence
        /// can be empty, but it will never be null.
        /// </returns>
        public static IEnumerable<Transition> GetTransitions(State oldState, State newState)
        {
            switch (oldState)
            {
                case State.None:
                    if (newState is State.Maintenance)
                    {
                        yield return Transition.FromNoneToMaintenance;
                    }
                    if (newState is State.None)
                    {
                        yield return Transition.FromNoneToNone;
                    }
                    if (newState is State.Processing)
                    {
                        yield return Transition.FromNoneToProcessing;
                    }
                    if (newState is State.Setup)
                    {
                        yield return Transition.FromNoneToSetup;
                    }
                    break;
                case State.Maintenance:
                    if (newState is State.Maintenance)
                    {
                        yield return Transition.FromMaintenanceToMaintenance;
                    }
                    if (newState is State.None)
                    {
                        yield return Transition.FromMaintenanceToNone;
                    }
                    if (newState is State.Processing)
                    {
                        yield return Transition.FromMaintenanceToProcessing;
                    }
                    if (newState is State.Setup)
                    {
                        yield return Transition.FromMaintenanceToSetup;
                    }
                    break;
                case State.Processing:
                    if (newState is State.Maintenance)
                    {
                        yield return Transition.FromProcessingToMaintenance;
                    }
                    if (newState is State.None)
                    {
                        yield return Transition.FromProcessingToNone;
                    }
                    if (newState is State.Processing)
                    {
                        yield return Transition.FromProcessingToProcessing;
                    }
                    if (newState is State.Setup)
                    {
                        yield return Transition.FromProcessingToSetup;
                    }
                    break;
                case State.Setup:
                    if (newState is State.Maintenance)
                    {
                        yield return Transition.FromSetupToMaintenance;
                    }
                    if (newState is State.None)
                    {
                        yield return Transition.FromSetupToNone;
                    }
                    if (newState is State.Processing)
                    {
                        yield return Transition.FromSetupToProcessing;
                    }
                    if (newState is State.Setup)
                    {
                        yield return Transition.FromSetupToSetup;
                    }
                    break;
            }
        }

        /// <summary>
        /// Retrieves a <see cref="LocalizedText"/> for the given state
        /// value.
        /// </summary>
        /// <param name="state">The state to get the text.</param>
        /// <returns>The text.</returns>
        public static LocalizedText GetLocalizedText(State state)
        {
            string text = state.ToString();
            return new LocalizedText(text, "", text);
        }

        /// <summary>
        /// Retrieves a <see cref="AbsoluteName"/> for the given state
        /// value.
        /// </summary>
        /// <param name="state">The state to get the name.</param>
        /// <returns>The name.</returns>
        public static AbsoluteName GetName(State state)
        {
            if (s_stateNames.TryGetValue(state, out var value))
            {
                return value;
            }

            return null;
        }

        /// <summary>
        /// Retrieves the <see cref="ExpandedNodeId"/> for the given state
        /// value.
        /// </summary>
        /// <param name="state">The state to get the ExpandedNodeId.</param>
        /// <returns>The ExpandedNodeId.</returns>
        public static ExpandedNodeId GetExpandedNodeId(State state)
        {
            if (s_stateNodeIds.TryGetValue(state, out var value))
            {
                return value;
            }

            return null;
        }

        private static readonly IDictionary<State, AbsoluteName> s_stateNames = new Dictionary<State, AbsoluteName>()
        {
            { State.None, new AbsoluteName(BrowseNames.None, Namespaces.Machinery) },
            { State.Maintenance, new AbsoluteName(BrowseNames.Maintenance, Namespaces.Machinery) },
            { State.Processing, new AbsoluteName(BrowseNames.Processing, Namespaces.Machinery) },
            { State.Setup, new AbsoluteName(BrowseNames.Setup, Namespaces.Machinery) },
        };

        private static readonly IDictionary<State, ExpandedNodeId> s_stateNodeIds = new Dictionary<State, ExpandedNodeId>()
        {
            { State.None, ObjectIds.MachineryOperationModeStateMachineType_None },
            { State.Maintenance, ObjectIds.MachineryOperationModeStateMachineType_Maintenance },
            { State.Processing, ObjectIds.MachineryOperationModeStateMachineType_Processing },
            { State.Setup, ObjectIds.MachineryOperationModeStateMachineType_Setup },
        };

        /// <summary>
        /// Retrieves a <see cref="LocalizedText"/> for the given transition
        /// value.
        /// </summary>
        /// <param name="transition">The transition to get the text.</param>
        /// <returns>The transition.</returns>
        public static LocalizedText GetLocalizedText(Transition transition)
        {
            string text = transition.ToString();
            return new LocalizedText(text, "", text);
        }

        /// <summary>
        /// Retrieves a <see cref="AbsoluteName"/> for the given transition
        /// value.
        /// </summary>
        /// <param name="transition">The transition to get the name.</param>
        /// <returns>The name.</returns>
        public static AbsoluteName GetName(Transition transition)
        {
            if (s_transitionNames.TryGetValue(transition, out var value))
            {
                return value;
            }

            return null;
        }

        /// <summary>
        /// Retrieves the <see cref="ExpandedNodeId"/> for the given transition
        /// value.
        /// </summary>
        /// <param name="transition">The transition to get the ExpandedNodeId.</param>
        /// <returns>The NodeId.</returns>
        public static ExpandedNodeId GetExpandedNodeId(Transition transition)
        {
            if (s_transitionNodeIds.TryGetValue(transition, out var value))
            {
                return value;
            }

            return null;
        }

        private static readonly IDictionary<Transition, AbsoluteName> s_transitionNames = new Dictionary<Transition, AbsoluteName>()
        {
            { Transition.FromMaintenanceToMaintenance, new AbsoluteName(BrowseNames.FromMaintenanceToMaintenance, Namespaces.Machinery) },
            { Transition.FromMaintenanceToNone, new AbsoluteName(BrowseNames.FromMaintenanceToNone, Namespaces.Machinery) },
            { Transition.FromMaintenanceToProcessing, new AbsoluteName(BrowseNames.FromMaintenanceToProcessing, Namespaces.Machinery) },
            { Transition.FromMaintenanceToSetup, new AbsoluteName(BrowseNames.FromMaintenanceToSetup, Namespaces.Machinery) },
            { Transition.FromNoneToMaintenance, new AbsoluteName(BrowseNames.FromNoneToMaintenance, Namespaces.Machinery) },
            { Transition.FromNoneToNone, new AbsoluteName(BrowseNames.FromNoneToNone, Namespaces.Machinery) },
            { Transition.FromNoneToProcessing, new AbsoluteName(BrowseNames.FromNoneToProcessing, Namespaces.Machinery) },
            { Transition.FromNoneToSetup, new AbsoluteName(BrowseNames.FromNoneToSetup, Namespaces.Machinery) },
            { Transition.FromProcessingToMaintenance, new AbsoluteName(BrowseNames.FromProcessingToMaintenance, Namespaces.Machinery) },
            { Transition.FromProcessingToNone, new AbsoluteName(BrowseNames.FromProcessingToNone, Namespaces.Machinery) },
            { Transition.FromProcessingToProcessing, new AbsoluteName(BrowseNames.FromProcessingToProcessing, Namespaces.Machinery) },
            { Transition.FromProcessingToSetup, new AbsoluteName(BrowseNames.FromProcessingToSetup, Namespaces.Machinery) },
            { Transition.FromSetupToMaintenance, new AbsoluteName(BrowseNames.FromSetupToMaintenance, Namespaces.Machinery) },
            { Transition.FromSetupToNone, new AbsoluteName(BrowseNames.FromSetupToNone, Namespaces.Machinery) },
            { Transition.FromSetupToProcessing, new AbsoluteName(BrowseNames.FromSetupToProcessing, Namespaces.Machinery) },
            { Transition.FromSetupToSetup, new AbsoluteName(BrowseNames.FromSetupToSetup, Namespaces.Machinery) },
        };

        private static readonly IDictionary<Transition, ExpandedNodeId> s_transitionNodeIds = new Dictionary<Transition, ExpandedNodeId>()
        {
            { Transition.FromMaintenanceToMaintenance, ObjectIds.MachineryOperationModeStateMachineType_FromMaintenanceToMaintenance },
            { Transition.FromMaintenanceToNone, ObjectIds.MachineryOperationModeStateMachineType_FromMaintenanceToNone },
            { Transition.FromMaintenanceToProcessing, ObjectIds.MachineryOperationModeStateMachineType_FromMaintenanceToProcessing },
            { Transition.FromMaintenanceToSetup, ObjectIds.MachineryOperationModeStateMachineType_FromMaintenanceToSetup },
            { Transition.FromNoneToMaintenance, ObjectIds.MachineryOperationModeStateMachineType_FromNoneToMaintenance },
            { Transition.FromNoneToNone, ObjectIds.MachineryOperationModeStateMachineType_FromNoneToNone },
            { Transition.FromNoneToProcessing, ObjectIds.MachineryOperationModeStateMachineType_FromNoneToProcessing },
            { Transition.FromNoneToSetup, ObjectIds.MachineryOperationModeStateMachineType_FromNoneToSetup },
            { Transition.FromProcessingToMaintenance, ObjectIds.MachineryOperationModeStateMachineType_FromProcessingToMaintenance },
            { Transition.FromProcessingToNone, ObjectIds.MachineryOperationModeStateMachineType_FromProcessingToNone },
            { Transition.FromProcessingToProcessing, ObjectIds.MachineryOperationModeStateMachineType_FromProcessingToProcessing },
            { Transition.FromProcessingToSetup, ObjectIds.MachineryOperationModeStateMachineType_FromProcessingToSetup },
            { Transition.FromSetupToMaintenance, ObjectIds.MachineryOperationModeStateMachineType_FromSetupToMaintenance },
            { Transition.FromSetupToNone, ObjectIds.MachineryOperationModeStateMachineType_FromSetupToNone },
            { Transition.FromSetupToProcessing, ObjectIds.MachineryOperationModeStateMachineType_FromSetupToProcessing },
            { Transition.FromSetupToSetup, ObjectIds.MachineryOperationModeStateMachineType_FromSetupToSetup },
        };
        #endregion

    }
    #endregion



}
