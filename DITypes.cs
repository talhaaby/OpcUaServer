/******************************************************************************
**
** <auto-generated>
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.6.9, using .NET Server 3.3.0 template (version 0)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
** </auto-generated>
**
** Copyright (c) 2006-2023 Unified Automation GmbH All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** Project: .NET OPC UA SDK information model for namespace http://opcfoundation.org/UA/DI/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
******************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Linq;
using System.Runtime.Serialization;
using UnifiedAutomation.UaBase;
using System.Diagnostics;

namespace OpcUa.DI
{
    #region UpdateBehavior flags
    /// <summary>
    /// https://reference.opcfoundation.org/DI/v104/docs/8.5.2
    /// </summary>
    [DataContract(Namespace = OpcUa.DI.Namespaces.DIXsd)]
    [Obsolete("Use UpdateBehavior instead")]
    [Flags]
    public enum UpdateBehaviorFlags : uint
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        /// <summary>
        /// If KeepsParameters is not set, the device will lose its configuration during update. The Client should do a backup of the parameters before the update and restore them afterwards.
        /// </summary>
        [EnumMember(Value = "KeepsParameters_1")]
        KeepsParameters = 1,
        /// <summary>
        /// If WillDisconnect is set, the OPC UA Server will restart during installation. This can be the case if the update is about the firmware of the device that hosts the OPC UA Server.
        /// </summary>
        [EnumMember(Value = "WillDisconnect_2")]
        WillDisconnect = 2,
        /// <summary>
        /// If RequiresPowerCycle is set, the devices require a manual power off / power on for installation.
        /// </summary>
        [EnumMember(Value = "RequiresPowerCycle_4")]
        RequiresPowerCycle = 4,
        /// <summary>
        /// If WillReboot is set, the device will reboot during the update, inclusive of embedded infrastructure elements like an integrated switch. An update Client should take this into account since the devices behind an integrated switch are not reachable for that time.
        /// </summary>
        [EnumMember(Value = "WillReboot_8")]
        WillReboot = 8,
        /// <summary>
        /// If NeedsPreparation is not set, the Client can install the update without maintaining the PrepareForUpdateStateMachine. This can be used to support an installation without stopping the software.
        /// </summary>
        [EnumMember(Value = "NeedsPreparation_16")]
        NeedsPreparation = 16,
    }

    /// <summary>
    /// https://reference.opcfoundation.org/DI/v104/docs/8.5.2
    /// </summary>
    [DataContract(Namespace = OpcUa.DI.Namespaces.DIXsd)]
    [Flags]
    public enum UpdateBehavior : uint
    {
        /// <summary>
        /// No bit is set
        /// </summary>
        [EnumMember(Value = "None_0")]
        None = 0,
        /// <summary>
        /// If KeepsParameters is not set, the device will lose its configuration during update. The Client should do a backup of the parameters before the update and restore them afterwards.
        /// </summary>
        [EnumMember(Value = "KeepsParameters_1")]
        KeepsParameters = 1,
        /// <summary>
        /// If WillDisconnect is set, the OPC UA Server will restart during installation. This can be the case if the update is about the firmware of the device that hosts the OPC UA Server.
        /// </summary>
        [EnumMember(Value = "WillDisconnect_2")]
        WillDisconnect = 2,
        /// <summary>
        /// If RequiresPowerCycle is set, the devices require a manual power off / power on for installation.
        /// </summary>
        [EnumMember(Value = "RequiresPowerCycle_4")]
        RequiresPowerCycle = 4,
        /// <summary>
        /// If WillReboot is set, the device will reboot during the update, inclusive of embedded infrastructure elements like an integrated switch. An update Client should take this into account since the devices behind an integrated switch are not reachable for that time.
        /// </summary>
        [EnumMember(Value = "WillReboot_8")]
        WillReboot = 8,
        /// <summary>
        /// If NeedsPreparation is not set, the Client can install the update without maintaining the PrepareForUpdateStateMachine. This can be used to support an installation without stopping the software.
        /// </summary>
        [EnumMember(Value = "NeedsPreparation_16")]
        NeedsPreparation = 16,
    }
    #endregion

    #region DeviceHealthEnumeration
    /// <summary>
    /// https://reference.opcfoundation.org/DI/v104/docs/4.5.4
    /// </summary>
    [DataContract(Namespace = OpcUa.DI.Namespaces.DIXsd)]
    public enum DeviceHealthEnumeration
    {
        /// <summary>
        /// This device functions normally.
        /// </summary>
        [EnumMember(Value = "NORMAL_0")]
        NORMAL = 0,
        /// <summary>
        /// Malfunction of the device or any of its peripherals.
        /// </summary>
        [EnumMember(Value = "FAILURE_1")]
        FAILURE = 1,
        /// <summary>
        /// Functional checks are currently performed.
        /// </summary>
        [EnumMember(Value = "CHECK_FUNCTION_2")]
        CHECK_FUNCTION = 2,
        /// <summary>
        /// The device is currently working outside of its specified range or that internal diagnoses indicate deviations from measured or set values.
        /// </summary>
        [EnumMember(Value = "OFF_SPEC_3")]
        OFF_SPEC = 3,
        /// <summary>
        /// This element is working, but a maintenance operation is required.
        /// </summary>
        [EnumMember(Value = "MAINTENANCE_REQUIRED_4")]
        MAINTENANCE_REQUIRED = 4,
    }

    #region DeviceHealthEnumerationCollection Class
    /// <summary>
    /// A collection of DeviceHealthEnumeration objects.
    /// </summary>
    [CollectionDataContract]
    public partial class DeviceHealthEnumerationCollection : List<DeviceHealthEnumeration>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public DeviceHealthEnumerationCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public DeviceHealthEnumerationCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public DeviceHealthEnumerationCollection(IEnumerable<DeviceHealthEnumeration> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator DeviceHealthEnumerationCollection(DeviceHealthEnumeration[] values)
        {
            if (values != null)
            {
                return new DeviceHealthEnumerationCollection(values);
            }

            return new DeviceHealthEnumerationCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator DeviceHealthEnumeration[](DeviceHealthEnumerationCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            DeviceHealthEnumerationCollection clone = new DeviceHealthEnumerationCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((DeviceHealthEnumeration)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion

    #endregion

    #region SoftwareVersionFileType
    /// <summary>
    /// https://reference.opcfoundation.org/DI/v104/docs/8.5.1
    /// </summary>
    [DataContract(Namespace = OpcUa.DI.Namespaces.DIXsd)]
    public enum SoftwareVersionFileType
    {
        /// <summary>
        /// The currently used version of the software identified by the CurrentVersion Object.
        /// </summary>
        [EnumMember(Value = "Current_0")]
        Current = 0,
        /// <summary>
        /// The pending version of the software that could be installed identified by the PendingVersion Object.
        /// </summary>
        [EnumMember(Value = "Pending_1")]
        Pending = 1,
        /// <summary>
        /// The fallback version of the software identified by the FallbackVersion Object.
        /// </summary>
        [EnumMember(Value = "Fallback_2")]
        Fallback = 2,
    }

    #region SoftwareVersionFileTypeCollection Class
    /// <summary>
    /// A collection of SoftwareVersionFileType objects.
    /// </summary>
    [CollectionDataContract]
    public partial class SoftwareVersionFileTypeCollection : List<SoftwareVersionFileType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public SoftwareVersionFileTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public SoftwareVersionFileTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public SoftwareVersionFileTypeCollection(IEnumerable<SoftwareVersionFileType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator SoftwareVersionFileTypeCollection(SoftwareVersionFileType[] values)
        {
            if (values != null)
            {
                return new SoftwareVersionFileTypeCollection(values);
            }

            return new SoftwareVersionFileTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator SoftwareVersionFileType[](SoftwareVersionFileTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            SoftwareVersionFileTypeCollection clone = new SoftwareVersionFileTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((SoftwareVersionFileType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion

    #endregion

    #region FetchResultDataType Class
    /// <summary>
    /// https://reference.opcfoundation.org/DI/v104/docs/6.4.6
    /// </summary>
    [DataContract(Namespace = OpcUa.DI.Namespaces.DIXsd)]
    public partial class FetchResultDataType : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public FetchResultDataType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
        }
        #endregion

        #region Public Properties

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return DataTypeIds.FetchResultDataType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId { get { return NodeId.Null; } }

        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId { get { return NodeId.Null; } }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(Namespaces.DIXsd);


            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(Namespaces.DIXsd);

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            FetchResultDataType value = encodeable as FetchResultDataType;

            if (value == null)
            {
                return false;
            }

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            FetchResultDataType clone = (FetchResultDataType)this.MemberwiseClone();


            return clone;
        }
        #endregion

        #region Private Fields
        #endregion
    }

    #region FetchResultDataTypeCollection class
    /// <summary>
    /// A collection of FetchResultDataType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfFetchResultDataType", Namespace = OpcUa.DI.Namespaces.DI, ItemName = "FetchResultDataType")]
    public partial class FetchResultDataTypeCollection : List<FetchResultDataType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public FetchResultDataTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public FetchResultDataTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public FetchResultDataTypeCollection(IEnumerable<FetchResultDataType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator FetchResultDataTypeCollection(FetchResultDataType[] values)
        {
            if (values != null)
            {
                return new FetchResultDataTypeCollection(values);
            }

            return new FetchResultDataTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator FetchResultDataType[](FetchResultDataTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            FetchResultDataTypeCollection clone = new FetchResultDataTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((FetchResultDataType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region TransferResultDataDataType Class
    /// <summary>
    /// https://reference.opcfoundation.org/DI/v104/docs/6.4.6
    /// </summary>
    [DataContract(Namespace = OpcUa.DI.Namespaces.DIXsd)]
    public partial class TransferResultDataDataType : FetchResultDataType
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public TransferResultDataDataType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_SequenceNumber = (int)0;
            m_EndOfResults = false;
            m_ParameterDefs = new ParameterResultDataTypeCollection();
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "SequenceNumber", IsRequired = false, Order = 1)]
        public int SequenceNumber
        {
            get
            {
                return m_SequenceNumber;
            }
            set
            {
                m_SequenceNumber = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "EndOfResults", IsRequired = false, Order = 2)]
        public bool EndOfResults
        {
            get
            {
                return m_EndOfResults;
            }
            set
            {
                m_EndOfResults = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "ParameterDefs", IsRequired = false, Order = 3)]
        public ParameterResultDataTypeCollection ParameterDefs
        {
            get
            {
                return m_ParameterDefs;
            }
            set
            {
                m_ParameterDefs = value;

                if (value == null)
                {
                    m_ParameterDefs = new ParameterResultDataTypeCollection();
                }
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public override ExpandedNodeId TypeId
        {
            get { return DataTypeIds.TransferResultDataDataType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public override ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.TransferResultDataDataType_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public override ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.TransferResultDataDataType_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public override void Encode(IEncoder encoder)
        {
            base.Encode(encoder);

            encoder.PushNamespace(Namespaces.DIXsd);

            encoder.WriteInt32("SequenceNumber", SequenceNumber);
            encoder.WriteBoolean("EndOfResults", EndOfResults);
            encoder.WriteEncodeableArray("ParameterDefs", ParameterDefs.ToArray(), typeof(ParameterResultDataType));

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public override void Decode(IDecoder decoder)
        {
            base.Decode(decoder);

            decoder.PushNamespace(Namespaces.DIXsd);
            SequenceNumber = decoder.ReadInt32("SequenceNumber");
            EndOfResults = decoder.ReadBoolean("EndOfResults");
            ParameterDefs = (ParameterResultDataTypeCollection) decoder.ReadEncodeableArray("ParameterDefs", typeof(ParameterResultDataType));

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public override bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            TransferResultDataDataType value = encodeable as TransferResultDataDataType;

            if (value == null)
            {
                return false;
            }

            if (!base.IsEqual(encodeable)) return false;

            if (!TypeUtils.IsEqual(m_SequenceNumber, value.m_SequenceNumber)) return false;
            if (!TypeUtils.IsEqual(m_EndOfResults, value.m_EndOfResults)) return false;
            if (!TypeUtils.IsEqual(m_ParameterDefs, value.m_ParameterDefs)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public override object Clone()
        {
            TransferResultDataDataType clone = (TransferResultDataDataType)base.Clone();

            clone.m_SequenceNumber = (int)TypeUtils.Clone(this.m_SequenceNumber);
            clone.m_EndOfResults = (bool)TypeUtils.Clone(this.m_EndOfResults);
            clone.m_ParameterDefs = (ParameterResultDataTypeCollection)TypeUtils.Clone(this.m_ParameterDefs);

            return clone;
        }
        #endregion

        #region Private Fields
        private int m_SequenceNumber;
        private bool m_EndOfResults;
        private ParameterResultDataTypeCollection m_ParameterDefs;
        #endregion
    }

    #region TransferResultDataDataTypeCollection class
    /// <summary>
    /// A collection of TransferResultDataDataType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfTransferResultDataDataType", Namespace = OpcUa.DI.Namespaces.DI, ItemName = "TransferResultDataDataType")]
    public partial class TransferResultDataDataTypeCollection : List<TransferResultDataDataType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public TransferResultDataDataTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public TransferResultDataDataTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public TransferResultDataDataTypeCollection(IEnumerable<TransferResultDataDataType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator TransferResultDataDataTypeCollection(TransferResultDataDataType[] values)
        {
            if (values != null)
            {
                return new TransferResultDataDataTypeCollection(values);
            }

            return new TransferResultDataDataTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator TransferResultDataDataType[](TransferResultDataDataTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            TransferResultDataDataTypeCollection clone = new TransferResultDataDataTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((TransferResultDataDataType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region TransferResultErrorDataType Class
    /// <summary>
    /// https://reference.opcfoundation.org/DI/v104/docs/6.4.6
    /// </summary>
    [DataContract(Namespace = OpcUa.DI.Namespaces.DIXsd)]
    public partial class TransferResultErrorDataType : FetchResultDataType
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public TransferResultErrorDataType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_Status = (int)0;
            m_Diagnostics = null;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "Status", IsRequired = false, Order = 1)]
        public int Status
        {
            get
            {
                return m_Status;
            }
            set
            {
                m_Status = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Diagnostics", IsRequired = false, Order = 2)]
        public DiagnosticInfo Diagnostics
        {
            get
            {
                return m_Diagnostics;
            }
            set
            {
                m_Diagnostics = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public override ExpandedNodeId TypeId
        {
            get { return DataTypeIds.TransferResultErrorDataType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public override ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.TransferResultErrorDataType_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public override ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.TransferResultErrorDataType_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public override void Encode(IEncoder encoder)
        {
            base.Encode(encoder);

            encoder.PushNamespace(Namespaces.DIXsd);

            encoder.WriteInt32("Status", Status);
            encoder.WriteDiagnosticInfo("Diagnostics", Diagnostics);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public override void Decode(IDecoder decoder)
        {
            base.Decode(decoder);

            decoder.PushNamespace(Namespaces.DIXsd);
            Status = decoder.ReadInt32("Status");
            Diagnostics = decoder.ReadDiagnosticInfo("Diagnostics");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public override bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            TransferResultErrorDataType value = encodeable as TransferResultErrorDataType;

            if (value == null)
            {
                return false;
            }

            if (!base.IsEqual(encodeable)) return false;

            if (!TypeUtils.IsEqual(m_Status, value.m_Status)) return false;
            if (!TypeUtils.IsEqual(m_Diagnostics, value.m_Diagnostics)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public override object Clone()
        {
            TransferResultErrorDataType clone = (TransferResultErrorDataType)base.Clone();

            clone.m_Status = (int)TypeUtils.Clone(this.m_Status);
            clone.m_Diagnostics = (DiagnosticInfo)TypeUtils.Clone(this.m_Diagnostics);

            return clone;
        }
        #endregion

        #region Private Fields
        private int m_Status;
        private DiagnosticInfo m_Diagnostics;
        #endregion
    }

    #region TransferResultErrorDataTypeCollection class
    /// <summary>
    /// A collection of TransferResultErrorDataType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfTransferResultErrorDataType", Namespace = OpcUa.DI.Namespaces.DI, ItemName = "TransferResultErrorDataType")]
    public partial class TransferResultErrorDataTypeCollection : List<TransferResultErrorDataType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public TransferResultErrorDataTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public TransferResultErrorDataTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public TransferResultErrorDataTypeCollection(IEnumerable<TransferResultErrorDataType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator TransferResultErrorDataTypeCollection(TransferResultErrorDataType[] values)
        {
            if (values != null)
            {
                return new TransferResultErrorDataTypeCollection(values);
            }

            return new TransferResultErrorDataTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator TransferResultErrorDataType[](TransferResultErrorDataTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            TransferResultErrorDataTypeCollection clone = new TransferResultErrorDataTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((TransferResultErrorDataType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion

    #region ParameterResultDataType Class
    /// <summary>
    /// https://reference.opcfoundation.org/DI/v104/docs/6.4.6
    /// </summary>
    [DataContract(Namespace = OpcUa.DI.Namespaces.DIXsd)]
    public partial class ParameterResultDataType : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public ParameterResultDataType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_NodePath = new QualifiedNameCollection();
            m_StatusCode = StatusCodes.Good;
            m_Diagnostics = null;
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "NodePath", IsRequired = false, Order = 1)]
        public QualifiedNameCollection NodePath
        {
            get
            {
                return m_NodePath;
            }
            set
            {
                m_NodePath = value;

                if (value == null)
                {
                    m_NodePath = new QualifiedNameCollection();
                }
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "StatusCode", IsRequired = false, Order = 2)]
        public StatusCode StatusCode
        {
            get
            {
                return m_StatusCode;
            }
            set
            {
                m_StatusCode = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Diagnostics", IsRequired = false, Order = 3)]
        public DiagnosticInfo Diagnostics
        {
            get
            {
                return m_Diagnostics;
            }
            set
            {
                m_Diagnostics = value;
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return DataTypeIds.ParameterResultDataType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.ParameterResultDataType_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.ParameterResultDataType_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(Namespaces.DIXsd);

            encoder.WriteQualifiedNameArray("NodePath", NodePath);
            encoder.WriteStatusCode("StatusCode", StatusCode);
            encoder.WriteDiagnosticInfo("Diagnostics", Diagnostics);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(Namespaces.DIXsd);
            NodePath = decoder.ReadQualifiedNameArray("NodePath");
            StatusCode = decoder.ReadStatusCode("StatusCode");
            Diagnostics = decoder.ReadDiagnosticInfo("Diagnostics");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            ParameterResultDataType value = encodeable as ParameterResultDataType;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_NodePath, value.m_NodePath)) return false;
            if (!TypeUtils.IsEqual(m_StatusCode, value.m_StatusCode)) return false;
            if (!TypeUtils.IsEqual(m_Diagnostics, value.m_Diagnostics)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            ParameterResultDataType clone = (ParameterResultDataType)this.MemberwiseClone();

            clone.m_NodePath = (QualifiedNameCollection)TypeUtils.Clone(this.m_NodePath);
            clone.m_StatusCode = (StatusCode)TypeUtils.Clone(this.m_StatusCode);
            clone.m_Diagnostics = (DiagnosticInfo)TypeUtils.Clone(this.m_Diagnostics);

            return clone;
        }
        #endregion

        #region Private Fields
        private QualifiedNameCollection m_NodePath;
        private StatusCode m_StatusCode;
        private DiagnosticInfo m_Diagnostics;
        #endregion
    }

    #region ParameterResultDataTypeCollection class
    /// <summary>
    /// A collection of ParameterResultDataType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfParameterResultDataType", Namespace = OpcUa.DI.Namespaces.DI, ItemName = "ParameterResultDataType")]
    public partial class ParameterResultDataTypeCollection : List<ParameterResultDataType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public ParameterResultDataTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public ParameterResultDataTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public ParameterResultDataTypeCollection(IEnumerable<ParameterResultDataType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator ParameterResultDataTypeCollection(ParameterResultDataType[] values)
        {
            if (values != null)
            {
                return new ParameterResultDataTypeCollection(values);
            }

            return new ParameterResultDataTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator ParameterResultDataType[](ParameterResultDataTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            ParameterResultDataTypeCollection clone = new ParameterResultDataTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((ParameterResultDataType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion


    #region EncodeableTypes
    /// <summary>
    /// Contains a method for registering all encodeable types of the namespace.
    /// </summary>
    public class EncodeableTypes
    {
        /// <summary>
        /// Register all encodeable types of the namespace at the communication stack.
        /// The Decoder will decode the registered types.
        /// </summary>
        public static void RegisterEncodeableTypes(MessageContext context)
        {
            context.Factory.AddEncodeableType(typeof(OpcUa.DI.TransferResultDataDataType));
            context.Factory.AddEncodeableType(typeof(OpcUa.DI.TransferResultErrorDataType));
            context.Factory.AddEncodeableType(typeof(OpcUa.DI.ParameterResultDataType));
        }
    }
    #endregion
}
